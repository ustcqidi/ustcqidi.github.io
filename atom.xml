<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>祁迪的博客</title>
  
  
  <link href="https://ustcqidi.github.io/atom.xml" rel="self"/>
  
  <link href="https://ustcqidi.github.io/"/>
  <updated>2025-01-04T02:47:49.190Z</updated>
  <id>https://ustcqidi.github.io/</id>
  
  <author>
    <name>祁迪</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2021 年度总结</title>
    <link href="https://ustcqidi.github.io/2021/12/27/summary-2021/"/>
    <id>https://ustcqidi.github.io/2021/12/27/summary-2021/</id>
    <published>2021-12-27T02:34:28.000Z</published>
    <updated>2025-01-04T02:47:49.190Z</updated>
    
    <content type="html"><![CDATA[<p>先看看去年立的 flag 的完成情况</p><span id="more"></span><h2 id="2021-年-flag"><a href="#2021-年-flag" class="headerlink" title="2021 年 flag"></a><strong>2021 年 flag</strong></h2><h3 id="理财-（基金定投）"><a href="#理财-（基金定投）" class="headerlink" title="理财 （基金定投）"></a><strong>理财 （基金定投）</strong></h3><ul><li>计划投入 50W</li><li>预期收益率 20%</li></ul><aside><br>💡 负收益，只能说是一塌糊涂 ！保持定投就可以了，不要瞎操作 ！！！<br><br></aside><h3 id="装修"><a href="#装修" class="headerlink" title="装修"></a><strong>装修</strong></h3><aside><br>💡 如期按照计划正常进行<br><br></aside><h3 id="跑步，控制体重在-60kg-以内"><a href="#跑步，控制体重在-60kg-以内" class="headerlink" title="跑步，控制体重在 60kg 以内"></a><strong>跑步，控制体重在 60kg 以内</strong></h3><aside><br>💡 跑步次数并不是很多，需要更加自律<br><br></aside><h3 id="减少体检异常指标"><a href="#减少体检异常指标" class="headerlink" title="减少体检异常指标"></a><strong>减少体检异常指标</strong></h3><aside><br>💡 喝酒太多<br>焦虑情绪太多<br>饮食结构 需要优化<br><br></aside><h3 id="陪儿子一起学习钢琴课程"><a href="#陪儿子一起学习钢琴课程" class="headerlink" title="陪儿子一起学习钢琴课程"></a><strong><del>陪儿子一起学习钢琴课程</del></strong></h3><aside><br>💡 儿子实在不喜欢钢琴，计划已经放弃<br><br></aside><h3 id="学完英语流利说：商务英语"><a href="#学完英语流利说：商务英语" class="headerlink" title="学完英语流利说：商务英语"></a><strong><del>学完英语流利说：商务英语</del></strong></h3><aside><br>💡 改成看 Youtube 技术 Channel<br><br></aside><h3 id="学完-CS155"><a href="#学完-CS155" class="headerlink" title="学完 CS155"></a><strong><del>学完 CS155</del></strong></h3><aside><br>💡 Project / Problem Based Learning, 没有完整地跟着课程学习<br><br></aside><h3 id="使用日程管理-App，做好任务清单、计划管理"><a href="#使用日程管理-App，做好任务清单、计划管理" class="headerlink" title="使用日程管理 App，做好任务清单、计划管理"></a><strong>使用日程管理 App，做好任务清单、计划管理</strong></h3><aside><br>💡 用 Notion 做 Worksapce，今年最大的收获<br><br></aside><h3 id="每个月看完两本书"><a href="#每个月看完两本书" class="headerlink" title="每个月看完两本书"></a><strong>每个月看完两本书</strong></h3><ul><li>用思维导图整理读书心得</li></ul><aside><br>💡 用微信读书读了 15 本，整体还是比较满意，开始把微信读书笔记整合同步到 Notion，学习卡片笔记等方法论，专业书籍读的偏少。<br><br></aside><h3 id="每周-每月总结复盘"><a href="#每周-每月总结复盘" class="headerlink" title="每周/每月总结复盘"></a><strong>每周/每月总结复盘</strong></h3><ul><li>计划完成情况</li><li>思考总结</li><li>输出 PPT</li></ul><aside><br>💡 Weekly Review 做的还比较满意<br><br></aside><hr><h2 id="2021-年回顾盘点"><a href="#2021-年回顾盘点" class="headerlink" title="2021 年回顾盘点"></a><strong>2021 年回顾盘点</strong></h2><h3 id="读了-15-本书"><a href="#读了-15-本书" class="headerlink" title="读了 15 本书"></a>读了 15 本书</h3><h3 id="跑步-200-多公里"><a href="#跑步-200-多公里" class="headerlink" title="跑步 200 多公里"></a>跑步 200 多公里</h3><h3 id="每周陪儿子打羽毛球，下象棋，教他用-Scratch-编程"><a href="#每周陪儿子打羽毛球，下象棋，教他用-Scratch-编程" class="headerlink" title="每周陪儿子打羽毛球，下象棋，教他用 Scratch 编程"></a>每周陪儿子打羽毛球，下象棋，教他用 Scratch 编程</h3><h3 id="用-Notion-做日程管理、文档、计划，整合-amp-优化了-Workflow"><a href="#用-Notion-做日程管理、文档、计划，整合-amp-优化了-Workflow" class="headerlink" title="用 Notion 做日程管理、文档、计划，整合 &amp; 优化了 Workflow"></a>用 Notion 做日程管理、文档、计划，整合 &amp; 优化了 Workflow</h3><h3 id="装修-1"><a href="#装修-1" class="headerlink" title="装修"></a>装修</h3><h3 id="924-剁手"><a href="#924-剁手" class="headerlink" title="924 剁手"></a>924 剁手</h3><p>太轻易相信别人，血的教训</p><h3 id="身体健康"><a href="#身体健康" class="headerlink" title="身体健康"></a><strong>身体健康</strong></h3><ul><li>体检情况比 2020 年严重，各种亚健康问题凸显</li></ul><h3 id="家庭关系"><a href="#家庭关系" class="headerlink" title="家庭关系"></a>家庭关系</h3><ul><li>跟父母关系处理的比较糟糕，沟通太少</li><li>更多的亲子陪伴时间</li><li>跟老婆的沟通太少</li></ul><h3 id="Side-Project"><a href="#Side-Project" class="headerlink" title="Side Project"></a>Side Project</h3><ul><li>完整上线了 Google Slide 插件</li></ul><hr><h2 id="2022-年度目标"><a href="#2022-年度目标" class="headerlink" title="2022 年度目标"></a>2022 年度目标</h2><h3 id="保持健康"><a href="#保持健康" class="headerlink" title="保持健康"></a>保持健康</h3><ul><li>不酗酒、少熬夜</li><li>午休</li><li>保持积极、愉悦的心情</li><li>少吃腌制食品，减少外出就餐</li><li>保持运动</li></ul><h3 id="家庭关系-1"><a href="#家庭关系-1" class="headerlink" title="家庭关系"></a>家庭关系</h3><ul><li>多跟家人聊天、沟通</li><li>保持和谐的家庭氛围，减少抱怨，不要轻易发脾气</li><li>亲子陪伴：羽毛球、象棋、Scratch 编程</li></ul><h3 id="个人成长"><a href="#个人成长" class="headerlink" title="个人成长"></a>个人成长</h3><ul><li>学习提高认知以及专业能力<ul><li>Blog</li><li>YouTube Channel</li></ul></li><li>戒骄戒躁，每天晚上读读书</li><li>戒掉不良习惯，争取摆脱最近几年的 “魔咒”</li><li>高质量完成工作</li><li>控制情绪，减少内耗</li></ul><h3 id="财务"><a href="#财务" class="headerlink" title="财务"></a>财务</h3><ul><li>保持定投，不要瞎操作。尽量不亏钱。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;先看看去年立的 flag 的完成情况&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>TUN &amp; TAP</title>
    <link href="https://ustcqidi.github.io/2021/05/24/tun-tap/"/>
    <id>https://ustcqidi.github.io/2021/05/24/tun-tap/</id>
    <published>2021-05-24T15:04:02.000Z</published>
    <updated>2025-01-04T02:21:58.770Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看 “Let’s Code Your own TCP/IP Stack” 系列文章，有点类似 “自己动手写 TCP/IP” 协议栈之类的。乍一看貌似一个不可能完成的任务，但是作者通过 5 篇文章逐步讲解，我居然看懂了。</p><span id="more"></span><p>这其中大多数都是介绍网络协议的实现细节，比如 ARP 的 Header 格式、解析，TCP 的三次握手细节，重传算法，拥塞控制机制的实现等。我个人比较感兴趣的是，应用层如何拿到原始的网络数据包？</p><p>作者开篇就介绍了，使用 TUN &amp; TAP 即可。晚上查阅了一些资料，真是打开了一扇门的感觉。原来我们平时使用的 VPN, 虚拟化技术之类的都得依赖 TUN &amp; TAP。</p><p>这篇文章零散记录了 TAP 和 TUN 的一些资料。</p><h2 id="什么是-TUN-TAP"><a href="#什么是-TUN-TAP" class="headerlink" title="什么是 TUN/TAP"></a>什么是 TUN/TAP</h2><blockquote><p>TUN/TAP provides packet reception and transmission for user space programs.</p></blockquote><p>TUN 和 TAP Linux 内核的虚拟网络设备 </p><ul><li>TUN 是 network tunnel driver 的缩写</li><li>TAP 是 <strong><em>Test Anything Protocol</em></strong> 的缩写</li></ul><p>TUN 和 TAP 在网络栈中的关系如图：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/418ae0e8-cf80-4cbc-8c5f-df72fe6f2ef2/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210524%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20210524T151315Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=951d7993e5024d3c045da9b1c3b6ed6fa891cdcadd7acff1efbf76d7444c610c&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt></p><h2 id="TUN-和-TAP-的应用场景"><a href="#TUN-和-TAP-的应用场景" class="headerlink" title="TUN 和 TAP 的应用场景"></a>TUN 和 TAP 的应用场景</h2><ul><li>The first one is <strong>VPN</strong> software (such as OpenVPN). In this scenario, the kernel sends its network packets to the tun or tap devices. The VPN software will then encrypt and forward them to the other side of the VPN tunnel where they get decrypted and delivered to their destination.</li><li>The second area in which tun and tap devices are popular are system virtualization/emulation packages.</li><li>NAT</li></ul><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><ul><li>OpenVPN 创建 tun</li><li>代码读取 tun 数据</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://backreference.org/2010/03/26/tuntap-interface-tutorial/">tuntap-interface-tutorial</a></li><li>虚拟化技术：libvirt &amp; QEMU &amp; KVM</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在看 “Let’s Code Your own TCP/IP Stack” 系列文章，有点类似 “自己动手写 TCP/IP” 协议栈之类的。乍一看貌似一个不可能完成的任务，但是作者通过 5 篇文章逐步讲解，我居然看懂了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络" scheme="https://ustcqidi.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>几个好习惯</title>
    <link href="https://ustcqidi.github.io/2021/03/28/2021-habit/"/>
    <id>https://ustcqidi.github.io/2021/03/28/2021-habit/</id>
    <published>2021-03-28T14:00:08.000Z</published>
    <updated>2025-01-04T02:21:58.654Z</updated>
    
    <content type="html"><![CDATA[<p>最近养成了几个很不错的习惯。</p><h3 id="更高效的笔记系统和事务管理"><a href="#更高效的笔记系统和事务管理" class="headerlink" title="更高效的笔记系统和事务管理"></a>更高效的笔记系统和事务管理</h3><p>学会使用 Notion 打造自己的知识体系和工作笔记，利用 Dashboard 管理日常事务。在 <a href="https://ustcqidi.github.io/2020/02/11/note">关于工作笔记</a> 这篇文章中，描述了我是如何一步一步优化我的笔记系统。</p><span id="more"></span><p>Notion 是目前我接触到的最优秀的笔记系统，相比 git 托管笔记，有以下优势：</p><ul><li>全端自动同步，不需要反复 push &amp; pull</li><li>并且支持模板导入，可以参考一些大佬的模板做自己的知识体系搭建、日常事务管理</li><li>功能特别丰富，社区比较完善</li><li>自带日程管理功能，不需要额外下载日程管理软件</li><li>比较丰富的排版方式，支持代码块、pdf、图片、dashboard、list、图表等等</li><li>支持一键导出为 html，markdown 方便入库备份</li><li>使用浏览器插件一键导入正在浏览的网页，便于引用外部资料</li><li>网页端使用体验很棒，不需要下载 app 也可以高效完成笔记，手机端可以直接访问网页书签，快速查看个人笔记</li><li>所见即所得的编辑效果，默认排版也很美观</li><li>核心功能全部免费</li></ul><p>目前我正在逐步把我工作笔记迁移到 Notion。</p><p>另外，也优化了工作笔记结构：</p><ul><li>Daily Work Memo: 记录每天的工作计划、问题细节等等，有点流水账的意思</li><li>Weekly Review: 每周的总结反思，包括工作周报、个人成长以及家庭生活等各方面的反思</li><li>Upcoming Release: 使用 JIRA Filter 方式自动生成每个 Release Task 表格，高效方便</li><li>Research &amp; Enhancement: 记录一些需有优化但是不紧急的调研任务</li><li>Pending Tickets: 记录一些正在处理的 tickets，也是使用 JIRA Filter 管理的</li></ul><h3 id="关注优秀的-Youtube-Channel"><a href="#关注优秀的-Youtube-Channel" class="headerlink" title="关注优秀的 Youtube Channel"></a>关注优秀的 Youtube Channel</h3><p>特别提一下，我是在 Youtube 看了 “老石谈芯” 的这期 <a href="https://www.youtube.com/watch?v=NHTMs1z88uA&amp;list=PLZbVf-X2rhjYnNwWZRb4wIgBjiyAsGKTL&amp;index=8">这就是最棒的效率软件！如果不是，我倒想试试你的 | Notion使用技巧分享</a> 开始种草 Notion 的。尽管我不是做芯片的，但是这个 Channel 的视频让我受益匪浅。</p><p>我以前也关注过不少技术相关 Channel, 但其实没有仔细利用好这些资源。Youtube 上有海量优质的技术视频，对提高自己的技术视野还有英语听力非常有帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近养成了几个很不错的习惯。&lt;/p&gt;
&lt;h3 id=&quot;更高效的笔记系统和事务管理&quot;&gt;&lt;a href=&quot;#更高效的笔记系统和事务管理&quot; class=&quot;headerlink&quot; title=&quot;更高效的笔记系统和事务管理&quot;&gt;&lt;/a&gt;更高效的笔记系统和事务管理&lt;/h3&gt;&lt;p&gt;学会使用 Notion 打造自己的知识体系和工作笔记，利用 Dashboard 管理日常事务。在 &lt;a href=&quot;https://ustcqidi.github.io/2020/02/11/note&quot;&gt;关于工作笔记&lt;/a&gt; 这篇文章中，描述了我是如何一步一步优化我的笔记系统。&lt;/p&gt;</summary>
    
    
    
    
    <category term="杂记" scheme="https://ustcqidi.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2020 年度总结</title>
    <link href="https://ustcqidi.github.io/2020/12/27/summary-2020/"/>
    <id>https://ustcqidi.github.io/2020/12/27/summary-2020/</id>
    <published>2020-12-27T13:29:49.000Z</published>
    <updated>2025-01-04T02:21:58.747Z</updated>
    
    <content type="html"><![CDATA[<p>先看看去年立的 flag 的完成情况</p><h3 id="2019年-flag"><a href="#2019年-flag" class="headerlink" title="2019年 flag"></a>2019年 flag</h3><ul><li>看 2-3 部高分纪录片<ul><li>零散地看了《一本好书》、李永乐老师、PaperClip、一席演讲 等</li><li>需要明确要看什么纪录片，并且很好利用碎片化时间<span id="more"></span></li></ul></li><li>读书/听书，电台<ul><li>每天上下班基本都会听书，今年听了这些：<ul><li>聊斋志异</li><li>红楼梦</li><li>鬼吹灯</li><li>美的沉思</li><li>价值投资</li><li>童林传</li><li>大唐惊雷</li><li>四世同堂</li></ul></li><li>三好坏男孩</li><li>故事 FM</li></ul></li><li>1-2 周写一篇博客，书写有助于思考<ul><li>全年写了 13 篇 blog，主要是工作中遇到的问题沉淀，比如 网络、security、libcurl 等</li></ul></li><li>每晚坐在书桌前至少半小时<ul><li>喝酒+晃晃悠悠频率有高</li></ul></li><li>尽量控制情绪，不要乱发脾气<ul><li>继续加油</li></ul></li><li>买改善房<ul><li>完成</li></ul></li><li>带老婆孩子去一次日本<ul><li>疫情原因今年一年基本都没出门，只去了一次九华山</li></ul></li><li>工作日保证 7点左右起床</li></ul><h3 id="理财计划"><a href="#理财计划" class="headerlink" title="理财计划"></a>理财计划</h3><ol><li>资金计划 10w+</li><li>周期1年</li><li>期望收益 10%+</li></ol><p>基本完成，今天收益 1w 左右，年中买房清仓一次。不然会赚的更多，今年计划基本完成。</p><h3 id="身体健康"><a href="#身体健康" class="headerlink" title="身体健康"></a>身体健康</h3><ul><li>少喝酒、保持身体健康、体检一次<ul><li>跟同事酒局有点多，要控制频率</li></ul></li><li>改善饮食结构，少油腻，少盐<ul><li>少吃了不少腌制类食物，经常吃公司的酸奶水果捞和减肥餐，还需要减少聚餐频率</li></ul></li><li>坚持定期跑步<ul><li>天气冷的时候没有跑</li></ul></li><li>争取每天午睡，晚上 11:00 左右睡觉，最晚不要超过 11:30 <ul><li>工作日的时候能做到早睡早起</li></ul></li></ul><hr><h2 id="2020-年回顾盘点"><a href="#2020-年回顾盘点" class="headerlink" title="2020 年回顾盘点"></a>2020 年回顾盘点</h2><h3 id="买房"><a href="#买房" class="headerlink" title="买房"></a>买房</h3><h3 id="兵棋推演项目"><a href="#兵棋推演项目" class="headerlink" title="兵棋推演项目"></a>兵棋推演项目</h3><p>赚了 10w 块，吸取了很多教训。</p><ol><li>极其耗费时间和精力，性价比极地。应该多思考如何增加被动收入。</li><li>不能轻易相信任何人，无脑地跟任何人掏心掏肺，会被别有用心的人利用。</li></ol><h3 id="libcurl-patch"><a href="#libcurl-patch" class="headerlink" title="libcurl patch"></a>libcurl patch</h3><p>提交了一个 patch 给 libcurl</p><p><a href="https://github.com/curl/curl/pull/5914">https://github.com/curl/curl/pull/5914</a></p><h3 id="917-学习小组"><a href="#917-学习小组" class="headerlink" title="917 学习小组"></a>917 学习小组</h3><p>难忘的封闭学习体验</p><h3 id="跑步"><a href="#跑步" class="headerlink" title="跑步"></a>跑步</h3><h3 id="身体健康-1"><a href="#身体健康-1" class="headerlink" title="身体健康"></a>身体健康</h3><p>一堆亚健康问题：轻度脂肪肝、尿酸高、高血压等等。急需调整饮食结构、生活方式。</p><h2 id="2021-年-flag"><a href="#2021-年-flag" class="headerlink" title="2021 年 flag"></a>2021 年 flag</h2><h3 id="理财-（基金定投）"><a href="#理财-（基金定投）" class="headerlink" title="理财 （基金定投）"></a>理财 （基金定投）</h3><ul><li>计划投入 50W</li><li>预期收益率 20%</li></ul><h3 id="装修"><a href="#装修" class="headerlink" title="装修"></a>装修</h3><h3 id="跑步，控制体重在-60kg-以内"><a href="#跑步，控制体重在-60kg-以内" class="headerlink" title="跑步，控制体重在 60kg 以内"></a>跑步，控制体重在 60kg 以内</h3><h3 id="减少体检异常指标"><a href="#减少体检异常指标" class="headerlink" title="减少体检异常指标"></a>减少体检异常指标</h3><h3 id="陪儿子一起学习钢琴课程"><a href="#陪儿子一起学习钢琴课程" class="headerlink" title="陪儿子一起学习钢琴课程"></a>陪儿子一起学习钢琴课程</h3><h3 id="学完英语流利说：商务英语"><a href="#学完英语流利说：商务英语" class="headerlink" title="学完英语流利说：商务英语"></a>学完英语流利说：商务英语</h3><h3 id="学完-CS155"><a href="#学完-CS155" class="headerlink" title="学完 CS155"></a>学完 CS155</h3><h3 id="使用日程管理-App，做好任务清单、计划管理"><a href="#使用日程管理-App，做好任务清单、计划管理" class="headerlink" title="使用日程管理 App，做好任务清单、计划管理"></a>使用日程管理 App，做好任务清单、计划管理</h3><h3 id="每个月看完两本书"><a href="#每个月看完两本书" class="headerlink" title="每个月看完两本书"></a>每个月看完两本书</h3><ul><li>用思维导图整理读书心得</li></ul><h3 id="每周-每月总结复盘"><a href="#每周-每月总结复盘" class="headerlink" title="每周/每月总结复盘"></a>每周/每月总结复盘</h3><ul><li>计划完成情况</li><li>思考总结</li><li>输出 PPT</li></ul><hr><h2 id="常用-App-年度总结"><a href="#常用-App-年度总结" class="headerlink" title="常用 App 年度总结"></a>常用 App 年度总结</h2><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><p><img src="/2020/12/27/summary-2020/neteasy_music.jpeg" alt></p><h3 id="豆瓣"><a href="#豆瓣" class="headerlink" title="豆瓣"></a>豆瓣</h3><p><img src="/2020/12/27/summary-2020/douban.jpg" alt></p><h3 id="微信读书"><a href="#微信读书" class="headerlink" title="微信读书"></a>微信读书</h3><p><img src="/2020/12/27/summary-2020/weread.png" alt></p><h3 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h3><p><img src="/2020/12/27/summary-2020/alipay.png" alt></p><h3 id="bilibili"><a href="#bilibili" class="headerlink" title="bilibili"></a>bilibili</h3><p><img src="/2020/12/27/summary-2020/bilibili.png" alt></p><h3 id="跑步-1"><a href="#跑步-1" class="headerlink" title="跑步"></a>跑步</h3><p><img src="/2020/12/27/summary-2020/joyrun.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;先看看去年立的 flag 的完成情况&lt;/p&gt;
&lt;h3 id=&quot;2019年-flag&quot;&gt;&lt;a href=&quot;#2019年-flag&quot; class=&quot;headerlink&quot; title=&quot;2019年 flag&quot;&gt;&lt;/a&gt;2019年 flag&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;看 2-3 部高分纪录片&lt;ul&gt;
&lt;li&gt;零散地看了《一本好书》、李永乐老师、PaperClip、一席演讲 等&lt;/li&gt;
&lt;li&gt;需要明确要看什么纪录片，并且很好利用碎片化时间&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    
    <category term="年度总结" scheme="https://ustcqidi.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>发出一个网络请求有多难</title>
    <link href="https://ustcqidi.github.io/2020/10/18/network-issue/"/>
    <id>https://ustcqidi.github.io/2020/10/18/network-issue/</id>
    <published>2020-10-18T12:51:04.000Z</published>
    <updated>2025-01-04T02:21:58.733Z</updated>
    
    <content type="html"><![CDATA[<p>我们已经习惯各种 App 带来的便利：聊天、订外卖、叫车、刷抖音。其实看是简单的操作比如打开一个网站，发送一个表情，都涉及大量网络请求。完成一次网络请求其实也挺难的，我相信所有用户量大的 App 一定都做了很多应用层面的网络优化。</p><span id="more"></span><h2 id="网络请求流程"><a href="#网络请求流程" class="headerlink" title="网络请求流程"></a>网络请求流程</h2><p>先看一下一个网络请求需要经历哪些流程，现在绝大多数的网站 / App 都是 https, 所以这里只描述 https 请求的流程。</p><p>首先是域名解析，通过域名查询对应的 host IP 地址；然后就是 TCP 连接这个 IP 地址；最后是 TLS 握手建立安全的数据通道，而后就可以收发数据了。</p><p>看上去整个流通也挺简单的，但是这里面每一步都有可能出现问题。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><ul><li>运营商劫持</li><li>域名污染</li><li>本地配置 host</li><li>DNS 服务配置有问题</li></ul><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul><li>防火墙限制</li></ul><h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><ul><li>SSL Inspector</li><li>自签名证书</li><li>抓包工具</li><li>代理服务器</li></ul><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li>PAC</li></ul><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><ul><li>BASIC</li><li>Digest</li><li>NTLM</li><li>Kerbose</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们已经习惯各种 App 带来的便利：聊天、订外卖、叫车、刷抖音。其实看是简单的操作比如打开一个网站，发送一个表情，都涉及大量网络请求。完成一次网络请求其实也挺难的，我相信所有用户量大的 App 一定都做了很多应用层面的网络优化。&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络" scheme="https://ustcqidi.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>给 curl 提了一个 patch</title>
    <link href="https://ustcqidi.github.io/2020/10/18/curl-patch/"/>
    <id>https://ustcqidi.github.io/2020/10/18/curl-patch/</id>
    <published>2020-10-18T12:16:23.000Z</published>
    <updated>2025-01-04T02:21:58.692Z</updated>
    
    <content type="html"><![CDATA[<p>最近把 curl 升级到了 7.71.1 版本，然后 NTLM 认证又又又又出问题了。问题表现是开启了抓包工具后 NTLM 认证就一直失败，给官方报了一个 Issue，<a href="https://github.com/curl/curl/issues/5911">NTLM authentication fails when using proxy without username and password</a></p><p>然后尝试给官方提了一个 Pull Request，最终被合到 master 分支。<a href="https://github.com/curl/curl/pull/5914">Pull Request</a></p><p>这是我第一次给开源社区贡献代码，还是挺激动的。</p><p>有几点收获这里记录一下：</p><ul><li>发现开源项目问题，主动分析原因，思考解决方法</li><li>如果解决了问题，思考一下能否回馈开源社区，尽量找到 Root Cause，不要用 Workaround</li><li>通常开源项目都有自己的代码风格，提交 Pull Request 时要遵守项目的代码风格、通过各种静态检查。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近把 curl 升级到了 7.71.1 版本，然后 NTLM 认证又又又又出问题了。问题表现是开启了抓包工具后 NTLM 认证就一直失败，给官方报了一个 Issue，&lt;a href=&quot;https://github.com/curl/curl/issues/5911&quot;&gt;NT</summary>
      
    
    
    
    
    <category term="网络" scheme="https://ustcqidi.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="cURL" scheme="https://ustcqidi.github.io/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>libcurl 考古</title>
    <link href="https://ustcqidi.github.io/2020/08/08/curl-history/"/>
    <id>https://ustcqidi.github.io/2020/08/08/curl-history/</id>
    <published>2020-08-08T14:08:49.000Z</published>
    <updated>2025-01-04T02:21:58.688Z</updated>
    
    <content type="html"><![CDATA[<p>晚上在浏览 curl github 上的 tag, 好奇心驱使。我翻到了 curl 的第一个 release tag: curl-6_5</p><span id="more"></span><p><img src="/2020/08/08/curl-history/tag.png" alt></p><p>tag 的创建日期是 2000年5月14日，至今已经20余年了，当时我才读小学，有种穿越时空的奇妙感觉。</p><p>一直想学习一些 curl 的源码，可惜最新版本的代码量太大了，数据结构和调用关系错综复杂无从入手。第一版本应该是只支持了最基础的功能，果断下载。</p><p>相比之下，代码量少了很多。结构也简单明了不少。</p><p>对照着官方的release note，以及commit id，学习大佬怎么一步一步把 curl 做成今天的样子，真有挖到宝藏的感觉。</p><p>这是官方 doc. 里最早的几个版本的 release note</p><p><img src="/2020/08/08/curl-history/releasenote.png" alt></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="RESOURCES-文件记录了一些-RFC-文档"><a href="#RESOURCES-文件记录了一些-RFC-文档" class="headerlink" title="RESOURCES 文件记录了一些 RFC 文档"></a>RESOURCES 文件记录了一些 RFC 文档</h3><ul><li>RFC 959  - Defines how FTP works</li><li>RFC 1738 - Uniform Resource Locators</li><li>RFC 1777 - defines the LDAP protocol</li><li>RFC 1808 - Relative Uniform Resource Locators</li><li><p>RFC 1867 - Form-based File Upload in HTML</p></li><li><p>RFC 1950 - ZLIB Compressed Data Format Specification</p></li><li>RFC 1951 - DEFLATE Compressed Data Format Specification</li><li><p>RFC 1952 - gzip compression format</p></li><li><p>RFC 1959 - LDAP URL syntax</p></li><li>RFC 2045-2049 - Everything you need to know about MIME! (needed for form based upload)</li><li>RFC 2068 - HTTP 1.1 (obsoleted by RFC 2616)</li><li>RFC 2109 - HTTP State Management Mechanism (cookie stuff)</li><li>Netscape’s specification at <a href="http://www.netscape.com/newsref/std/cookie_spec.html">http://www.netscape.com/newsref/std/cookie_spec.html</a></li><li>RFC 2183 - “The Content-Disposition Header Field”</li><li>RFC 2229 - “A Dictionary Server Protocol”</li><li>RFC 2231 - “MIME Parameter Value and Encoded Word Extensions: Character Sets, Languages, and Continuations”</li><li>RFC 2388 - “Returning Values from Forms: multipart/form-data” Use this as an addition to the 1867 </li><li>RFC 2396 - “Uniform Resource Identifiers: Generic Syntax and Semantics” </li><li>RFC 2428 - “FTP Extensions for IPv6 and NATs”</li><li>RFC 2616 - HTTP 1.1</li><li>RFC 2617 - HTTP Authentication</li></ul><h3 id="FEATURES-文件记录了支持的-feature"><a href="#FEATURES-文件记录了支持的-feature" class="headerlink" title="FEATURES 文件记录了支持的 feature"></a>FEATURES 文件记录了支持的 feature</h3><ol><li><p>Misc</p><ul><li>full URL syntax</li><li>custom maximum download time</li><li>custom least download speed acceptable</li><li>multiple URLs</li><li>guesses protocol from host name unless specified</li><li>uses .netrc</li><li>progress bar/time specs while downloading</li><li>PROXY environment variables support</li><li>config file support</li><li>compiles on win32</li></ul></li><li><p>HTTP</p><ul><li>GET</li><li>PUT</li><li>HEAD</li><li>POST</li><li>multipart POST</li><li>authentication</li><li>resume</li><li>follow redirects</li><li>custom HTTP request</li><li>cookie get/send</li><li>custom headers (that can replace internally generated headers)</li><li>custom user-agent string</li><li>custom referer string</li><li>range</li><li>proxy authentication</li><li>time conditions</li><li>via http-proxy</li></ul></li><li><p>HTTPS (*1)</p><ul><li>(all the HTTP features)</li><li>using certificates</li><li>via http-proxy</li></ul></li><li><p>FTP</p><ul><li>download</li><li>authentication</li><li>PORT or PASV</li><li>single file size information (compare to HTTP HEAD)</li><li>‘type=’ URL support</li><li>dir listing</li><li>dir listing names-only</li><li>upload</li><li>upload append</li><li>upload via http-proxy as HTTP PUT</li><li>download resume</li><li>upload resume</li><li>QUOT commands (before and/or after the transfer)</li><li>simple “range” support</li><li>via http-proxy</li></ul></li><li><p>TELNET</p><ul><li>connection negotiation</li><li>stdin/stdout I/O</li></ul></li><li><p>LDAP (*2)</p><ul><li>full LDAP URL support</li></ul></li><li><p>DICT</p><ul><li>extended DICT URL support</li></ul></li><li><p>GOPHER</p><ul><li>GET</li><li>via http-proxy</li></ul></li><li><p>FILE</p><ul><li><p>URL support</p><p>  <em>1 = requires OpenSSL  </em>2 = requires OpenLDAP</p></li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;晚上在浏览 curl github 上的 tag, 好奇心驱使。我翻到了 curl 的第一个 release tag: curl-6_5&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络" scheme="https://ustcqidi.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="cURL" scheme="https://ustcqidi.github.io/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>我的时间和精力管理</title>
    <link href="https://ustcqidi.github.io/2020/07/09/time-mgr/"/>
    <id>https://ustcqidi.github.io/2020/07/09/time-mgr/</id>
    <published>2020-07-08T23:08:49.000Z</published>
    <updated>2025-01-04T02:21:58.770Z</updated>
    
    <content type="html"><![CDATA[<p>早上跑步时在思考一个问题：如何合理地分配时间和精力，才能高效地完成工作、平衡家庭生活、个人娱乐、健身以及学习。</p><p>其实从考研时开始我就一直在关注时间分配，尝试过各种大家耳熟能详的方法：番茄工作法、四象限管理。</p><span id="more"></span><p>但是简单盘点回顾一下，其实我做的不够好，至少效果不够好：</p><ul><li>工作上每个项目基本是被 push 着走，虽然近期有一些客观原因，但本质上是我自己做的不够好。</li><li>工作上非常缺乏定期思考、总结！目前我的“总结”停留在记录工作事务流水账的层面上。严重缺乏思考，包括专业和业务方面。</li></ul><p>究其原因，可能跟我平时工作习惯很大。合理分配管理精力非常重要，这篇文章盘点总结了一下我工作和生活的时间分配原则，按照计划执行一段时间再看看效果。</p><h3 id="工作事务类型盘点及时间分配"><a href="#工作事务类型盘点及时间分配" class="headerlink" title="工作事务类型盘点及时间分配"></a>工作事务类型盘点及时间分配</h3><h4 id="事务类型"><a href="#事务类型" class="headerlink" title="事务类型"></a>事务类型</h4><ul><li>各种会议，比如项目讨论、技术方案讨论、公共模块日常答疑、troubleshooting 会议</li><li>Ticket</li><li>线上 Crash</li><li>项目日常事务</li><li>总结与学习</li></ul><h4 id="时间分配原则"><a href="#时间分配原则" class="headerlink" title="时间分配原则"></a>时间分配原则</h4><ul><li>上午处理邮件、回复 ticket、开会、技术调研</li><li>下午3点以后IM设置成请勿打扰、非紧急会议不参加</li><li>下午3点以后专注 coding、技术调研</li><li>如没有紧急问题，每周5下午用来学习+总结</li><li>每天安排一个最高优先级事务</li></ul><h3 id="个人娱乐、健身、学习"><a href="#个人娱乐、健身、学习" class="headerlink" title="个人娱乐、健身、学习"></a>个人娱乐、健身、学习</h3><ul><li>每周六打一次羽毛球/游泳</li><li>微信读书 (午休时)</li><li>公开课、演讲 (午休时)</li><li>脱口秀电台 (午休时)</li><li>音乐 (工作背景音乐)</li><li>热剧、电影 (午休时)</li><li>蜻蜓FM听书 (上下班通勤、洗碗时)</li><li>保持早起跑步习惯</li></ul><h3 id="家庭生活"><a href="#家庭生活" class="headerlink" title="家庭生活"></a>家庭生活</h3><ul><li>每晚陪儿子读书</li><li>周六陪儿子上英语课</li><li>周六陪父母吃饭</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;早上跑步时在思考一个问题：如何合理地分配时间和精力，才能高效地完成工作、平衡家庭生活、个人娱乐、健身以及学习。&lt;/p&gt;
&lt;p&gt;其实从考研时开始我就一直在关注时间分配，尝试过各种大家耳熟能详的方法：番茄工作法、四象限管理。&lt;/p&gt;</summary>
    
    
    
    
    <category term="杂记" scheme="https://ustcqidi.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
    <category term="工作效率" scheme="https://ustcqidi.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>最近的几件大事</title>
    <link href="https://ustcqidi.github.io/2020/07/07/diary-7-7/"/>
    <id>https://ustcqidi.github.io/2020/07/07/diary-7-7/</id>
    <published>2020-07-07T00:55:43.000Z</published>
    <updated>2025-01-04T02:21:58.692Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>交首付，办贷款<br>希望股票行权收益能及时到账</p></li><li><p>处理 12 分交通违章<br>花钱真的可使鬼推磨</p></li><li><p>体检<br>2-3 年没体检了，希望一切顺利</p></li></ol><p>PS: 早睡早起、坚持跑步、定期盘点总结工作生活。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;交首付，办贷款&lt;br&gt;希望股票行权收益能及时到账&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;处理 12 分交通违章&lt;br&gt;花钱真的可使鬼推磨&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;体检&lt;br&gt;2-3 年没体检了，希望一切顺利&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;PS</summary>
      
    
    
    
    
    <category term="杂记" scheme="https://ustcqidi.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Security</title>
    <link href="https://ustcqidi.github.io/2020/06/03/security/"/>
    <id>https://ustcqidi.github.io/2020/06/03/security/</id>
    <published>2020-06-03T14:05:11.000Z</published>
    <updated>2025-01-04T02:21:58.743Z</updated>
    
    <content type="html"><![CDATA[<p>最近整个公司是谈 “Security” 色变，每周一个 Release 也折腾的我们够呛。这个期间我们修复了无数个安全漏洞，这里简单总结一下，细节就不描述了。</p><span id="more"></span><h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><h3 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h3><h3 id="敏感信息泄漏-（PII-Cookie-Token）"><a href="#敏感信息泄漏-（PII-Cookie-Token）" class="headerlink" title="敏感信息泄漏 （PII/Cookie/Token）"></a>敏感信息泄漏 （PII/Cookie/Token）</h3><h3 id="Remote-Code-Execution"><a href="#Remote-Code-Execution" class="headerlink" title="Remote Code Execution"></a>Remote Code Execution</h3><h3 id="各种第三方库升级"><a href="#各种第三方库升级" class="headerlink" title="各种第三方库升级"></a>各种第三方库升级</h3><h3 id="加密-哈希算法升级"><a href="#加密-哈希算法升级" class="headerlink" title="加密/哈希算法升级"></a>加密/哈希算法升级</h3><h3 id="第三方开源库-License-审核"><a href="#第三方开源库-License-审核" class="headerlink" title="第三方开源库 License 审核"></a>第三方开源库 License 审核</h3><h3 id="政策法规方面"><a href="#政策法规方面" class="headerlink" title="政策法规方面"></a>政策法规方面</h3><h3 id="代码缺陷"><a href="#代码缺陷" class="headerlink" title="代码缺陷"></a>代码缺陷</h3><h4 id="Buffer-Overflow"><a href="#Buffer-Overflow" class="headerlink" title="Buffer Overflow"></a>Buffer Overflow</h4><h4 id="User-after-free"><a href="#User-after-free" class="headerlink" title="User after free"></a>User after free</h4><h4 id="Double-free"><a href="#Double-free" class="headerlink" title="Double free"></a>Double free</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近整个公司是谈 “Security” 色变，每周一个 Release 也折腾的我们够呛。这个期间我们修复了无数个安全漏洞，这里简单总结一下，细节就不描述了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="安全" scheme="https://ustcqidi.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>开发基础库需要注意什么</title>
    <link href="https://ustcqidi.github.io/2020/05/01/basic-func-test/"/>
    <id>https://ustcqidi.github.io/2020/05/01/basic-func-test/</id>
    <published>2020-05-01T12:21:56.000Z</published>
    <updated>2025-01-04T02:21:58.664Z</updated>
    
    <content type="html"><![CDATA[<p>最新公司产品需要全面优化加密算法，使用 AES-GCM 代替原来的 AES-CBC，我需要实现封装这个新的加解密接口。</p><span id="more"></span><p>实现这个基础方法，其实需要考虑的 case 还是挺多的，比如是否有多余的内存拷贝，针对无效输入做 buffer 越界保护，大小端以及各种异常情况下是否有内存泄漏等等。</p><p>这个基础方法并不复杂，但是考虑到所有产品线，所有客户端，甚至服务端都会调用这个接口做加解密，所以我们还是做了很多测试，以保证万无一失。</p><h3 id="文档文档文档"><a href="#文档文档文档" class="headerlink" title="文档文档文档"></a>文档文档文档</h3><p>文档非常非常重要，否则你每次都需要跟你的用户（基础库使用方）解释细节，直至暴走，怀疑人生。</p><h3 id="代码-Review"><a href="#代码-Review" class="headerlink" title="代码 Review"></a>代码 Review</h3><p>代码 Review 常常能发现一些低级手抖错误，我实现这个方法时没有仔细考虑内存拷贝的开销，Review 代码时同事指出来了，后来想了一下，大量数据加解密调用时，频繁地内存拷贝可能会导致内存碎片，影响性能。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试简直是 Common SDK 开发者的保命法宝。我在 <a href="https://ustcqidi.github.io/2019/01/14/chromium-testing/">Chromium 工程源码是如何测试的</a> 中提到过，Chromium 中所有基础库的代码都有大量的单元测试和性能测试。实现这个加解密方法时我写了大量的测试用例，测试了几波以后基本胸有成竹了。另外，如果产品源码编译时间很久的话，使用单元测试工程来开发会极大地提高效率。 </p><p>Daniel Stenberg 大哥有一个 <a href="https://www.youtube.com/watch?v=U572Hq8LiWw">curl development with Daniel</a> 系列，直播撸 curl 的 feature。围观了后，发现大哥也是写完代码后，用 testing 工程验证。</p><h3 id="Fuzzing-测试"><a href="#Fuzzing-测试" class="headerlink" title="Fuzzing 测试"></a>Fuzzing 测试</h3><p>Fuzzing 测试就是传入各种无效、随机、操蛋的参数，测试方法是否有异常，比如 Crash, 内存泄漏等等。通常需要写一些脚本随机生成脏数据，然后频繁地调用目标方法。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最新公司产品需要全面优化加密算法，使用 AES-GCM 代替原来的 AES-CBC，我需要实现封装这个新的加解密接口。&lt;/p&gt;</summary>
    
    
    
    
    <category term="基础库" scheme="https://ustcqidi.github.io/tags/%E5%9F%BA%E7%A1%80%E5%BA%93/"/>
    
    <category term="单元测试" scheme="https://ustcqidi.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    <category term="性能测试" scheme="https://ustcqidi.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    <category term="Fuzzing 测试" scheme="https://ustcqidi.github.io/tags/Fuzzing-%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>libcurl 陷阱</title>
    <link href="https://ustcqidi.github.io/2020/03/27/libcurl-pits/"/>
    <id>https://ustcqidi.github.io/2020/03/27/libcurl-pits/</id>
    <published>2020-03-27T15:09:58.000Z</published>
    <updated>2025-01-04T02:21:58.732Z</updated>
    
    <content type="html"><![CDATA[<p>记录项目使用 libcurl 时遇到的一些坑，持续更新！</p><span id="more"></span><h2 id="动态库卸载-Crash"><a href="#动态库卸载-Crash" class="headerlink" title="动态库卸载 Crash"></a>动态库卸载 Crash</h2><p>libcurl 作为动态库一部分，在动态库卸载时如果有 pending 的 dns 解析请求可能会导致 Crash。</p><ul><li><a href="https://github.com/curl/curl/issues/997">相关issue</a></li><li><a href="https://curl.haxx.se/libcurl/c/curl_global_cleanup.html">官方文档说明</a></li></ul><blockquote><p>curl_global_cleanup does not block waiting for any libcurl-created threads to terminate (such as threads used for name resolving). If a module containing libcurl is dynamically unloaded while libcurl-created threads are still running then your program may crash or other corruption may occur. We recommend you do not run libcurl from any module that may be unloaded dynamically. This behavior may be addressed in the future.</p></blockquote><h2 id="Connection-Cache-复用问题"><a href="#Connection-Cache-复用问题" class="headerlink" title="Connection Cache 复用问题"></a>Connection Cache 复用问题</h2><p>网络切换/中断、App前后台切换，可能会导致 Connection Cache 的 socket 连接实例失效，但是 libcurl 没有针对这种情况做 Connection Cache 的及时清理，导致连接复用时可能会出现连接失败。这个问题在 iOS, Mac 平台上很容易出现。</p><ul><li><a href="https://curl.haxx.se/mail/lib-2016-07/0032.html">相关讨论</a></li></ul><blockquote><p>I’ve got a situation where connection cache is kept through internet connection change (Wifi -&gt; 3G for example). After network change cURL will try to reuse the connection from cache and will fail and open a new connection. The problem is that it takes ~20 seconds to understand that the connection was dead.</p></blockquote><h2 id="WebSocket-支持"><a href="#WebSocket-支持" class="headerlink" title="WebSocket 支持"></a>WebSocket 支持</h2><p>主要思路是使用 libcurl 作 https 通信，具体的 websocket 协议解析与封装需要自己实现。但是有个问题，libcurl 官方是不支持 websocket，因此 websocket 请求实例拿到 response 以后。这个实例可能会被 re-use。当然，民间也有一些基于 libcurl 支持 websocket 的讨论。</p><ul><li><a href="https://curl.haxx.se/video/curlup-2017/2017-03-19_05_Michael_Kaufmann_Websocket_support_for_curl.mp4">https://curl.haxx.se/video/curlup-2017/2017-03-19_05_Michael_Kaufmann_Websocket_support_for_curl.mp4</a></li><li><a href="https://github.com/bagder/curl/pull/86">https://github.com/bagder/curl/pull/86</a></li><li><a href="https://gist.github.com/mkauf/5ce3574ce821b2cf02986d4d701bfa86">https://gist.github.com/mkauf/5ce3574ce821b2cf02986d4d701bfa86</a></li></ul><h2 id="NTLM-认证"><a href="#NTLM-认证" class="headerlink" title="NTLM 认证"></a>NTLM 认证</h2><p>这次升级 libcurl 到 7.71.1 版本后，NTLM 认证在 Android 和 iOS 上认证都会失败。之前升级 libcurl 到 7.55.1 时也遇到过 NTLM 认证的问题。</p><p>相比其他认证方式，NTLM 认证过程更为复杂，整体流程如下图：</p><p><img src="/2020/03/27/libcurl-pits/ntlm.png" alt></p><p>Client 和 Server 需要几次“握手”交换认证信息，并且要求这几次“握手”的连接实例是同一个。http(s) 是无状态连接，libcurl 本身也有 connection reuse 机制，所以可能有各种原因会导致，交换 NTLM 认证信息的几次连接可能使用的不是同一个实例，这就会导致认证失败。</p><p>我提交过几个 issue 给 libcurl，5911 这个 issue 是官方其中一个版本引入的 regression，我提了一个 PR Fix 了</p><p>Issues:</p><ul><li><a href="https://github.com/curl/curl/issues/3647">https://github.com/curl/curl/issues/3647</a></li><li><a href="https://github.com/curl/curl/issues/5693">https://github.com/curl/curl/issues/5693</a></li><li><a href="https://github.com/curl/curl/issues/5911">https://github.com/curl/curl/issues/5911</a></li></ul><p>Pull Request: </p><ul><li><a href="https://github.com/curl/curl/pull/5914">https://github.com/curl/curl/pull/5914</a></li></ul><p>这些使用上的坑也具有指导意义。</p><h3 id="Could-not-re-use-the-connection-for-NTLM-challenge-and-always-create-a-new-connection"><a href="#Could-not-re-use-the-connection-for-NTLM-challenge-and-always-create-a-new-connection" class="headerlink" title="Could not re-use the connection for NTLM challenge, and always create a new connection"></a>Could not re-use the connection for NTLM challenge, and always create a new connection</h3><h4 id="Root-Cause"><a href="#Root-Cause" class="headerlink" title="Root Cause"></a>Root Cause</h4><p>Connection 42 is still name resolving, can’t reuse. So create a new connection 43, which cause NTLM challenge failed, and cause once more redirect. It’s very wired because Connection 42 have left intact just now.</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>define the macro HAVE_GETPEERNAME</p><h4 id="abnormal-logs"><a href="#abnormal-logs" class="headerlink" title="abnormal logs"></a>abnormal logs</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[my_curl_debug_callback] This: 525811577016 TEXT :Connection #42 to host exchange2016.com left intact</span><br><span class="line">[my_curl_debug_callback] This: 525811577016 TEXT :Issue another request to this URL: &#x27;https://exchange2016.com/EWS/Exchange.asmx&#x27;</span><br><span class="line">[my_curl_debug_callback] This: 525811577016 TEXT :Found bundle for host exchange2016.com: 0x7a72130c30 [serially]</span><br><span class="line">[my_curl_debug_callback] This: 525811577016 TEXT :Connection #11 is still name resolving, can&#x27;t reuse</span><br><span class="line">[my_curl_debug_callback] This: 525811577016 TEXT :Connection #23 is still name resolving, can&#x27;t reuse</span><br><span class="line">[my_curl_debug_callback] This: 525811577016 TEXT :Connection #24 is still name resolving, can&#x27;t reuse</span><br><span class="line">[my_curl_debug_callback] This: 525811577016 TEXT :Connection #25 is still name resolving, can&#x27;t reuse</span><br><span class="line">[my_curl_debug_callback] This: 525811577016 TEXT :Connection #26 is still name resolving, can&#x27;t reuse</span><br><span class="line">[my_curl_debug_callback] This: 525811577016 TEXT :Connection #29 is still name resolving, can&#x27;t reuse</span><br><span class="line">[my_curl_debug_callback] This: 525811577016 TEXT :Connection #31 is still name resolving, can&#x27;t reuse</span><br><span class="line">[my_curl_debug_callback] This: 525811577016 TEXT :Connection #42 is still name resolving, can&#x27;t reuse</span><br><span class="line">[my_curl_debug_callback] This: 525811577016 TEXT :Hostname exchange2016.com was found in DNS cache</span><br><span class="line">[my_curl_debug_callback] This: 525811577016 TEXT :  Trying 10.100.87.8:443...</span><br><span class="line">[my_curl_debug_callback] This: 525811577016 TEXT :Connected to exchange2016.com () port 443 (#43)</span><br></pre></td></tr></table></figure><h4 id="normal-logs"><a href="#normal-logs" class="headerlink" title="normal logs"></a>normal logs</h4><p>Re-using existing connection! (43) for NTLM challenge</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[my_curl_debug_callback] This: 5412312248 TEXT :Connection #43 to host exchange2013.com left intact</span><br><span class="line">[my_curl_debug_callback] This: 5412312248 TEXT :Issue another request to this URL: &#x27;https://exchange2013.com/EWS/Exchange.asmx&#x27;</span><br><span class="line">[my_curl_debug_callback] This: 5412312248 TEXT :Found bundle for host exchange2013.com: 0x2823928e0 [serially]</span><br><span class="line">[my_curl_debug_callback] This: 5412312248 TEXT :Re-using existing connection! (#43) with host exchange2013.com</span><br><span class="line">[my_curl_debug_callback] This: 5412312248 TEXT :Connected to exchange2013.com () port 443 (#43)</span><br></pre></td></tr></table></figure><h3 id="Connection-cache-is-full-closing-the-oldest-one-Which-cause-could-not-re-use-the-connection-for-NTLM-challenge"><a href="#Connection-cache-is-full-closing-the-oldest-one-Which-cause-could-not-re-use-the-connection-for-NTLM-challenge" class="headerlink" title="Connection cache is full, closing the oldest one. Which cause could not re-use the connection for NTLM challenge"></a>Connection cache is full, closing the oldest one. Which cause could not re-use the connection for NTLM challenge</h3><h4 id="Root-Cause-1"><a href="#Root-Cause-1" class="headerlink" title="Root Cause"></a>Root Cause</h4><ul><li><p>Connection cache is full, closing the oldest one. So create a new connection 50, which cause NTLM challenge failed, and cause once more redirect. But why Closing connection 49, it seems to the latest one not oldest one.</p></li><li><p>websocket connections make the connection cache full, and can not be closed</p></li></ul><p>As following code snippet, for websocket connection we will set the connect_only as true, which will never be candidate connection for close.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// conncache.c</span><br><span class="line">struct connectdata *</span><br><span class="line">Curl_conncache_extract_oldest(struct Curl_easy *data) &#123;</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">    while(curr) &#123;</span><br><span class="line">      conn = curr-&gt;ptr;</span><br><span class="line"></span><br><span class="line">      if(!CONN_INUSE(conn) &amp;&amp; !conn-&gt;data &amp;&amp; !conn-&gt;bits.close &amp;&amp;</span><br><span class="line">         !conn-&gt;bits.connect_only) &#123;</span><br><span class="line">        /* Set higher score for the age passed since the connection was used */</span><br><span class="line">        score = Curl_timediff(now, conn-&gt;lastused);</span><br><span class="line"></span><br><span class="line">        if(score &gt; highscore) &#123;</span><br><span class="line">          highscore = score;</span><br><span class="line">          conn_candidate = conn;</span><br><span class="line">          bundle_candidate = bundle;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      curr = curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="abnormal-logs-1"><a href="#abnormal-logs-1" class="headerlink" title="abnormal logs"></a>abnormal logs</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :Connected to exchange2013.com () port 443 (#49)</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :ALPN, offering http/1.1</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :TLSv1.3 (OUT), TLS handshake, Client hello (1):</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :TLSv1.3 (IN), TLS handshake, Server hello (2):</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :TLSv1.2 (IN), TLS handshake, Certificate (11):</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :TLSv1.2 (IN), TLS handshake, Server key exchange (12):</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :TLSv1.2 (IN), TLS handshake, Server finished (14):</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :TLSv1.2 (OUT), TLS handshake, Client key exchange (16):</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :TLSv1.2 (OUT), TLS handshake, Finished (20):</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :TLSv1.2 (IN), TLS handshake, Finished (20):</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :SSL connection using TLSv1.2 / ECDHE-RSA-AES256-SHA384</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :ALPN, server did not agree to a protocol</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :Server certificate:</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT : subject: CN=*.com</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT : start date: Apr 22 00:00:00 2020 GMT</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT : expire date: Apr 22 23:59:59 2022 GMT</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT : subjectAltName: host &quot;exchange2013.com&quot; matched cert&#x27;s &quot;*.com&quot;</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT : issuer: C=GB; ST=Greater Manchester; L=Salford; O=Sectigo Limited; CN=Sectigo RSA Domain Validation Secure Server CA</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT : SSL certificate verify ok.</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :Server auth using NTLM with user &#x27;foo-bar&#x27;</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 HEADER_OUT :POST /EWS/Exchange.asmx HTTP/1.1</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :Mark bundle as not supporting multiuse</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 HEADER_IN :HTTP/1.1 401 Unauthorized</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 HEADER_IN :Server: Microsoft-IIS/7.5</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 HEADER_IN :request-id: 9811034b-32e4-45e5-b300-5be1efb8d8f3</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 HEADER_IN :WWW-Authenticate: balabalabalabalabalabalabalabalabalabala</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 HEADER_IN :WWW-Authenticate: Negotiate</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 HEADER_IN :X-Powered-By: ASP.NET</span><br><span class="line">my_curl_debug_callback] This: 5412314808 HEADER_IN :X-FEServer: WIN-1TRC9B5MS6A</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 HEADER_IN :Date: Thu, 16 Jul 2020 19:02:54 GMT</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 HEADER_IN :Content-Length: 0</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 HEADER_IN :</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :Connection cache is full, closing the oldest one.</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :Closing connection 49</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :TLSv1.2 (OUT), TLS alert, close notify (256):</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :Issue another request to this URL: &#x27;https://exchange2013.com/EWS/Exchange.asmx&#x27;</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :Found bundle for host exchange2013.com: 0x2823b9680 [serially]</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :Hostname exchange2013.com was found in DNS cache</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :  Trying 10.100.87.7:443...</span><br><span class="line">[my_curl_debug_callback] This: 5412314808 TEXT :Connected to exchange2013.com () port 443 (#50)</span><br></pre></td></tr></table></figure><h3 id="NTLM-Authenticate-always-failed-in-curl-7-71-1-if-Use-proxy-without-username-and-password"><a href="#NTLM-Authenticate-always-failed-in-curl-7-71-1-if-Use-proxy-without-username-and-password" class="headerlink" title="NTLM Authenticate always failed in curl 7.71.1 if Use proxy without username and password"></a>NTLM Authenticate always failed in curl 7.71.1 if Use proxy without username and password</h3><p>开启抓包工具使用没有用户名或密码的代理服务器，NTLM 就认证就会失败。</p><p>分析如下：</p><p>this code snippet seems to the condition alway as true if i have config proxy server without password, which maybe cause failed to reuse the connections for NTLM challenge.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#ifndef CURL_DISABLE_PROXY</span><br><span class="line">        /* Same for Proxy NTLM authentication */</span><br><span class="line">        if(wantProxyNTLMhttp) &#123;</span><br><span class="line">          /* Both check-&gt;http_proxy.user and check-&gt;http_proxy.passwd can be</span><br><span class="line">           * NULL */</span><br><span class="line">          if(!check-&gt;http_proxy.user || !check-&gt;http_proxy.passwd)</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">          if(strcmp(needle-&gt;http_proxy.user, check-&gt;http_proxy.user) ||</span><br><span class="line">             strcmp(needle-&gt;http_proxy.passwd, check-&gt;http_proxy.passwd))</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(check-&gt;proxy_ntlm_state != NTLMSTATE_NONE) &#123;</span><br><span class="line">          /* Proxy connection is using NTLM auth but we don&#x27;t want NTLM */</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h4 id="abnormal-logs-2"><a href="#abnormal-logs-2" class="headerlink" title="abnormal logs"></a>abnormal logs</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Line 6374: [18048:16268:09-04/10:49:34.941:INFO:(389)]TEXT :Found bundle for host xxx.com: 0xf781740 [serially]</span><br><span class="line">Line 6376: [18048:16268:09-04/10:49:34.941:INFO:(389)]TEXT :Re-using existing connection! (#8) with proxy 127.0.0.1</span><br><span class="line">Line 6378: [18048:16268:09-04/10:49:34.941:INFO:(389)]TEXT :Connected to 127.0.0.1 (127.0.0.1) port 8888 (#8)</span><br><span class="line">Line 6380: [18048:16268:09-04/10:49:34.941:INFO:(389)]TEXT :Server auth using NTLM with user &#x27;balabala&#x27;</span><br><span class="line">Line 6382: [18048:16268:09-04/10:49:34.941:INFO:(389)]HEADER_OUT :POST /EWS/Exchange.asmx HTTP/1.1</span><br><span class="line">Line 6385: [18048:16268:09-04/10:49:35.018:INFO:(389)]TEXT :Mark bundle as not supporting multiuse</span><br><span class="line">Line 6387: [18048:16268:09-04/10:49:35.018:DEBUG:(362)]HEADER_IN :HTTP/1.1 401 Unauthorized</span><br><span class="line">Line 6391: [18048:16268:09-04/10:49:35.018:DEBUG:(362)]HEADER_IN :Server: Microsoft-IIS/8.5</span><br><span class="line">Line 6395: [18048:16268:09-04/10:49:35.018:DEBUG:(362)]HEADER_IN :request-id: 8ae68c1b-25f1-449f-b911-0808b135cb44</span><br><span class="line">Line 6399: [18048:16268:09-04/10:49:35.018:DEBUG:(362)]HEADER_IN :WWW-Authenticate: NTLM TlRMTVNTUAACAAAAGAAYADgAAAAFgomiPXW5AdNSBywAAAAAAAAAAAoBCgFQAAAABgOAJQAAAA9FAFgAQwBIAEEATgBHAEUAMgAwADEANgACABgARQBYAEMASABBAE4ARwBFADIAMAAxADYAAQAeAFcASQBOAC0ARgA2AEYAMgBOAEkATQBOAFMASABNAAQAMABlAHgAYwBoAGEAbgBnAGUAMgAwADEANgAuAHMAdQB6AGgAbwB1AC4AegBvAG8AbQADAFAAVwBJAE4ALQBGADYARgAyAE4ASQBNAE4AUwBIAE0ALgBlAHgAYwBoAGEAbgBnAGUAMgAwADEANgAuAHMAdQB6AGgAbwB1AC4AegBvAG8AbQAFADAAZQB4AGMAaABhAG4AZwBlADIAMAAxADYALgBzAHUAegBoAG8AdQAuAHoAbwBvAG0ABwAIAEvkOQZmgtYBAAAAAA==</span><br><span class="line">Line 6403: [18048:16268:09-04/10:49:35.018:DEBUG:(362)]HEADER_IN :WWW-Authenticate: Negotiate</span><br><span class="line">Line 6407: [18048:16268:09-04/10:49:35.018:DEBUG:(362)]HEADER_IN :X-Powered-By: ASP.NET</span><br><span class="line">Line 6411: [18048:16268:09-04/10:49:35.018:DEBUG:(362)]HEADER_IN :X-FEServer: WIN-F6F2NIMNSHM</span><br><span class="line">Line 6415: [18048:16268:09-04/10:49:35.018:DEBUG:(362)]HEADER_IN :Date: Fri, 04 Sep 2020 02:49:35 GMT</span><br><span class="line">Line 6419: [18048:16268:09-04/10:49:35.018:DEBUG:(362)]HEADER_IN :Content-Length: 0</span><br><span class="line">Line 6423: [18048:16268:09-04/10:49:35.018:DEBUG:(362)]HEADER_IN :Proxy-Support: Session-Based-Authentication</span><br><span class="line">Line 6427: [18048:16268:09-04/10:49:35.018:DEBUG:(362)]HEADER_IN :</span><br><span class="line">Line 6429: [18048:16268:09-04/10:49:35.018:INFO:(389)]HEADER_IN :</span><br><span class="line">Line 6431: [18048:16268:09-04/10:49:35.018:INFO:(389)]TEXT :Connection #8 to host 127.0.0.1 left intact</span><br><span class="line">Line 6433: [18048:16268:09-04/10:49:35.018:INFO:(389)]TEXT :Issue another request to this URL: &#x27;https://xxx.com/EWS/Exchange.asmx&#x27;</span><br><span class="line">Line 6435: [18048:16268:09-04/10:49:35.018:INFO:(389)]TEXT :Found bundle for host xxx.com: 0xf781740 [serially]</span><br><span class="line">Line 6437: [18048:16268:09-04/10:49:35.018:INFO:(389)]TEXT :NTLM-proxy picked AND auth done set, clear picked!</span><br><span class="line">Line 6439: [18048:16268:09-04/10:49:35.018:INFO:(389)]TEXT :Hostname 127.0.0.1 was found in DNS cache</span><br><span class="line">Line 6441: [18048:16268:09-04/10:49:35.018:INFO:(389)]TEXT :  Trying 127.0.0.1:8888...</span><br><span class="line">Line 6445: [18048:16268:09-04/10:49:35.029:INFO:(389)]TEXT :Connected to 127.0.0.1 (127.0.0.1) port 8888 (#13)</span><br><span class="line">Line 6447: [18048:16268:09-04/10:49:35.029:INFO:(389)]TEXT :allocate connect buffer!</span><br><span class="line">Line 6449: [18048:16268:09-04/10:49:35.029:INFO:(389)]TEXT :Establish HTTP proxy tunnel to xxx.com:443</span><br></pre></td></tr></table></figure><p>出来混早晚是要还的，技术债务也是如此。少一些 Workaround，多一点 Root Cause。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录项目使用 libcurl 时遇到的一些坑，持续更新！&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络" scheme="https://ustcqidi.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="cURL" scheme="https://ustcqidi.github.io/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>提高效率的工具集</title>
    <link href="https://ustcqidi.github.io/2020/03/27/work-perf-tools/"/>
    <id>https://ustcqidi.github.io/2020/03/27/work-perf-tools/</id>
    <published>2020-03-27T12:29:59.000Z</published>
    <updated>2025-01-04T02:21:58.771Z</updated>
    
    <content type="html"><![CDATA[<p>工欲善其事，必先利其器。有效地使用工具能帮助我们快速定位、解决问题，提高工作效率。<a href="https://ustcqidi.github.io/2020/03/14/work-perf/">用脚本把繁杂、重复的工作自动化</a> 记录了我工作中写的一些提高工作效率的脚本。这篇文章主要记录一些我平时常用的工具。这两篇文章都会持续更新！</p><span id="more"></span><h2 id="XMind"><a href="#XMind" class="headerlink" title="XMind"></a>XMind</h2><p>思维导图工具，在我遇到一个没有头绪的问题、读比较复杂的代码或者文章时，会用思维导图工具整理思路。</p><h2 id="WebSequenceDiagrams"><a href="#WebSequenceDiagrams" class="headerlink" title="WebSequenceDiagrams"></a><a href="https://www.websequencediagrams.com/">WebSequenceDiagrams</a></h2><p>在线时序图编辑器，整理业务流程、代码逻辑神器</p><h2 id="mermaid"><a href="#mermaid" class="headerlink" title="mermaid"></a><a href="https://github.com/mjbvz/vscode-markdown-mermaid">mermaid</a></h2><p>VSCode 插件，可以在 markdown 文档中直接编辑时序图，替代在线时序图编辑器</p><h2 id="draw-io"><a href="#draw-io" class="headerlink" title="draw.io"></a><a href="https://draw.io">draw.io</a></h2><p>在线绘图工具，我通常用来绘制业务架构图</p><h2 id="gitee-私人仓库"><a href="#gitee-私人仓库" class="headerlink" title="gitee 私人仓库"></a>gitee 私人仓库</h2><p>存放、同步各种资料：工作笔记、重要文件、读书笔记、学习笔记等</p><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2><p>反汇编神器，准确定位具体 Crash 指令，解决 Crash 神器</p><h2 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h2><p>网络抓包/分析工具，需要加强学习</p><h2 id="Win-Notepad"><a href="#Win-Notepad" class="headerlink" title="[Win] Notepad++"></a>[Win] Notepad++</h2><p>看日志神器</p><h2 id="Win-Everything"><a href="#Win-Everything" class="headerlink" title="[Win] Everything"></a>[Win] Everything</h2><p>全盘文件搜索神器，方便查找各种文件，必不可少的工具之一</p><h2 id="Win-Total-Commander"><a href="#Win-Total-Commander" class="headerlink" title="[Win] Total Commander"></a>[Win] Total Commander</h2><p>骨灰级文件管理器，自定义快捷键高效跳转到高频使用的文件夹位置，一键在当前目录下打开 git bash 提交代码特别方便。另外还有双窗口视图，再也不用打开一堆文件管理器窗口了。更多强大功能还在挖掘中</p><h2 id="Win-WinDbg"><a href="#Win-WinDbg" class="headerlink" title="[Win] WinDbg"></a>[Win] WinDbg</h2><p>Win 调试工具，各种调试技巧挖掘中，需要加强学习</p><h2 id="Mac-iTerm-oh-my-zsh"><a href="#Mac-iTerm-oh-my-zsh" class="headerlink" title="[Mac] iTerm/oh-my-zsh"></a>[Mac] iTerm/oh-my-zsh</h2><p>Mac 命令行神器</p><h2 id="Mac-Alfred"><a href="#Mac-Alfred" class="headerlink" title="[Mac] Alfred"></a>[Mac] Alfred</h2><p>效率神器，但是我用的并不多，需要加强学习</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;工欲善其事，必先利其器。有效地使用工具能帮助我们快速定位、解决问题，提高工作效率。&lt;a href=&quot;https://ustcqidi.github.io/2020/03/14/work-perf/&quot;&gt;用脚本把繁杂、重复的工作自动化&lt;/a&gt; 记录了我工作中写的一些提高工作效率的脚本。这篇文章主要记录一些我平时常用的工具。这两篇文章都会持续更新！&lt;/p&gt;</summary>
    
    
    
    
    <category term="工作效率" scheme="https://ustcqidi.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87/"/>
    
    <category term="工具" scheme="https://ustcqidi.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>用脚本把繁杂、重复的工作自动化</title>
    <link href="https://ustcqidi.github.io/2020/03/14/work-perf/"/>
    <id>https://ustcqidi.github.io/2020/03/14/work-perf/</id>
    <published>2020-03-14T12:29:59.000Z</published>
    <updated>2025-01-04T02:21:58.772Z</updated>
    
    <content type="html"><![CDATA[<p>用脚本把所有繁杂、重复的工作自动化，是提升工作效率和身心愉悦感的很棒的方法。还能大幅度地降低人为操作的失误。</p><span id="more"></span><h2 id="JNIGenerator"><a href="#JNIGenerator" class="headerlink" title="JNIGenerator"></a>JNIGenerator</h2><p>Chromium 项目中大量地用 Python 脚步实现了各种工作的自动化，比如自动生成 JNI 接口。人肉写 JNI 接口很容易出错，需要记大量的 JNI 数据类型，非常痛苦。我把 Chromium 中的 JNI 接口生成以及相关基础 JNI 封装抽出来了。参考 <a href="https://github.com/ustcqidi/JNIGenerator">JNIGenerator</a></p><h2 id="ZMBuildDownloader"><a href="#ZMBuildDownloader" class="headerlink" title="ZMBuildDownloader"></a>ZMBuildDownloader</h2><p>平时工作中每次更新项目代码，都要从4个仓库拉一遍，还得从我们的 Build FTP 上，取最新的 Binary 替换本地的。这个工作用脚本实现自动化最合适不过了。 除了更新代码，我还经常需要从 FTP 上取最新的 build 测试，或者取某个 build 的符号文件来分析一些 Crash 问题。</p><p>大体分析了一下需求以后，我写了一个简单的脚本，可以从 FTP 上获取最新或者指定版本的 build/bianry/symbols 文件，顺便写了个自动更新代码的脚本，两个脚本一搭配效率迅速提升。再也不用蛋疼地打开 FileZilla 眯着眼找 build 了。</p><h2 id="批量删除-git-仓库本地分支"><a href="#批量删除-git-仓库本地分支" class="headerlink" title="批量删除 git 仓库本地分支"></a>批量删除 git 仓库本地分支</h2><h3 id="删除所有包含-trunk的本地分支"><a href="#删除所有包含-trunk的本地分支" class="headerlink" title="删除所有包含_trunk的本地分支"></a>删除所有包含_trunk的本地分支</h3><p>git branch | grep “_trunk” | xargs git branch -D</p><h3 id="删除所有不包含trunk的本地分支"><a href="#删除所有不包含trunk的本地分支" class="headerlink" title="删除所有不包含trunk的本地分支"></a>删除所有不包含trunk的本地分支</h3><p>git branch | grep -v “trunk” | xargs git branch -D</p><h2 id="日志清理脚本"><a href="#日志清理脚本" class="headerlink" title="日志清理脚本"></a>日志清理脚本</h2><p>一键清理垃圾日志文件，释放磁盘空间</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;用脚本把所有繁杂、重复的工作自动化，是提升工作效率和身心愉悦感的很棒的方法。还能大幅度地降低人为操作的失误。&lt;/p&gt;</summary>
    
    
    
    
    <category term="工作效率" scheme="https://ustcqidi.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87/"/>
    
    <category term="Python" scheme="https://ustcqidi.github.io/tags/Python/"/>
    
    <category term="自动化" scheme="https://ustcqidi.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>关于工作笔记</title>
    <link href="https://ustcqidi.github.io/2020/02/11/note/"/>
    <id>https://ustcqidi.github.io/2020/02/11/note/</id>
    <published>2020-02-11T09:10:39.000Z</published>
    <updated>2025-01-04T02:21:58.733Z</updated>
    
    <content type="html"><![CDATA[<p>我一直有记笔记的习惯，但是回头看来大多数情况下我的笔记质量很一般。</p><span id="more"></span><h2 id="手写"><a href="#手写" class="headerlink" title="手写"></a>手写</h2><p>刚开始实习时，用最原始的办法记笔记：手写。主要目的是整理思路、记下每周要做的事情等等。这种方式大概持续了 2-3 年，用完了好几个笔记本，但是基本没有沉淀。毕业、搬家、换工作几次事件后，基本把笔记本都弄丢了。</p><h2 id="云笔记-豆瓣"><a href="#云笔记-豆瓣" class="headerlink" title="云笔记 + 豆瓣"></a>云笔记 + 豆瓣</h2><p>开始有意识用云笔记记笔记，用过印象笔记、豆瓣。便于多端同步，现在来看当年在豆瓣上的笔记，基本属于日常事务流水账，主要汇总了每周/月所做的工作；基本没有知识总结，沉淀。</p><p><img src="/2020/02/11/note/douban_note.png" alt></p><h2 id="Git-托管"><a href="#Git-托管" class="headerlink" title="Git 托管"></a>Git 托管</h2><p>各种云笔记产品其实挺好用的，但是我使用过各种记笔记方法后，还是最倾向于使用 Git 托管笔记。</p><p>原因有以下几点：</p><ol><li>记事本 + markdown 轻量简洁的体验</li><li>便于保存各种 PPT, PDF 等文档</li><li>有提交历史，方便回滚</li></ol><p>这个习惯是从爱奇艺移动架构组工作开始的，当时我们每周都需要 PPT 总结本周工作，那段时间我积累了大量知识沉淀。</p><p><img src="/2020/02/11/note/iqiyi.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>来了 Zoom 以后，发现很多优秀的同事都有记笔记的习惯，我们每个 task 在具体写代码之前，都需要写 Design Doc., Test Case 等文档，这对我们思考非常有用。同时也可以沉淀大量文档，文档的重要性不言而喻，长远来看一些基础、重要的工作文档化以后，可以让我们工作的更轻松。</p><p>比如今天无意中看到一位技术支持同事的 Wiki Space 写了大量详尽的文档，包括常用工具用法、常见问题的分析、业务背景总结、技术沉淀等等；我相信这些文档一定有助于让他后面的工作更轻松高效。</p><p>我也梳理了一下我的工作文档目录：</p><p><img src="/2020/02/11/note/keynote2020.png" alt></p><p>财富是一点点积累出来的，知识也是，希望今年的工作过程中能注意多总结，多沉淀。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我一直有记笔记的习惯，但是回头看来大多数情况下我的笔记质量很一般。&lt;/p&gt;</summary>
    
    
    
    
    <category term="个人成长、知识积累" scheme="https://ustcqidi.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF%E3%80%81%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>先知.兵圣人机对抗赛</title>
    <link href="https://ustcqidi.github.io/2020/01/19/war-game-ai/"/>
    <id>https://ustcqidi.github.io/2020/01/19/war-game-ai/</id>
    <published>2020-01-19T15:24:39.000Z</published>
    <updated>2025-01-04T02:21:58.770Z</updated>
    
    <content type="html"><![CDATA[<p>先知.兵圣人机对抗赛是军方组织的兵棋 AI 对抗赛，目前只是在军方内部开放，我们是从某个外包上市公司接到这个项目的，上游需求方是某地方军事院校，情况比较复杂。很显然这个项目最终没有谈成，但这个比赛本身以及谈项目过程中的一些经验教训值得记录并反思。</p><span id="more"></span><h2 id="比赛相关"><a href="#比赛相关" class="headerlink" title="比赛相关"></a>比赛相关</h2><h3 id="离线训练引擎"><a href="#离线训练引擎" class="headerlink" title="离线训练引擎"></a>离线训练引擎</h3><p>主办方提供的离线训练环境，包括陆战和海战两部分，模拟实现真实比赛环境接口，比如获取态势信息，提交动作等，并提供了几个 Demo。参赛队伍只要专注 AI 算法就可以了，不得不说主办方提供的技术支持还是很到位的。</p><h3 id="复盘系统"><a href="#复盘系统" class="headerlink" title="复盘系统"></a>复盘系统</h3><p>离线训练引擎不能实时展示作战细节，只是把作战过程的每一步数据都保存到一个 json 文件中。使用主办方提供的复盘系统，可以对这个 json 文件可视化，复盘系统是用 java 写的 web 服务，启动服务后用浏览器访问即可。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法是这次比赛的核心点，我查阅了一些论文，以往的参赛队伍的算法是基于规则，顶多就是基于数据挖掘的方式。所谓基于规则，简单地说就是把兵棋规则用代码描述一遍，代码量会比较大，但是整体逻辑很容易被看出来，所以很难战胜人类选手。而主办方是希望参赛队伍基于 AI (深度强化学习) 实现并训练模型完成比赛，还特别强调最终胜出队伍中，优先对使用强化学习算法的队伍给予经费支持。</p><h3 id="Workflow"><a href="#Workflow" class="headerlink" title="Workflow"></a>Workflow</h3><p>算法实现、离线训练、复盘、代码托管等整体流程大体如下：</p><p><img src="/2020/01/19/war-game-ai/flow.png" alt></p><h2 id="一些经验教训"><a href="#一些经验教训" class="headerlink" title="一些经验教训"></a>一些经验教训</h2><ul><li>外包项目一定会有各种撕逼，包括但是不限于费用问题、合同细节、验收标准等等。所以接外包项目通常劳心劳力，投入产出比极低</li><li>除非项目本身特别有意义，比如恰好可以用你刚学的新技术练练手，或者对你的公司各种资质提升有价值 （需求方是政府、军方等大粗腿）</li><li>多方转包的项目坚决不能碰，单个需求方撕逼已经够累了，多方转包后撕逼难度和恶心度指数增长</li><li>不是一类人，千万别往一起凑。跟需求方/合作方沟通 1-2 次基本就大体了解对方办事风格，觉得不合适就赶紧终止合作。比如这次合作过程中我们就被各种小细节上恶心，最终决定终止合作！</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;先知.兵圣人机对抗赛是军方组织的兵棋 AI 对抗赛，目前只是在军方内部开放，我们是从某个外包上市公司接到这个项目的，上游需求方是某地方军事院校，情况比较复杂。很显然这个项目最终没有谈成，但这个比赛本身以及谈项目过程中的一些经验教训值得记录并反思。&lt;/p&gt;</summary>
    
    
    
    
    <category term="兵棋" scheme="https://ustcqidi.github.io/tags/%E5%85%B5%E6%A3%8B/"/>
    
    <category term="强化学习" scheme="https://ustcqidi.github.io/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Chromium 跨平台基础库：allocator</title>
    <link href="https://ustcqidi.github.io/2020/01/03/chromium-base-allocator/"/>
    <id>https://ustcqidi.github.io/2020/01/03/chromium-base-allocator/</id>
    <published>2020-01-03T13:38:05.000Z</published>
    <updated>2025-01-04T02:21:58.664Z</updated>
    
    <content type="html"><![CDATA[<p>allocator 是 C++ std 中引入的，为了处理各种内存管理模式（比如共享内存、垃圾回收等）的内存分配问题，负责内存的分配、回收，对象的创建析构等。</p><span id="more"></span><p>Chromium 的 base 库中有个 allocator 的目录，这是 Chromium 中使用的 allocator，为啥需要自己定义一个 allocator，不直接用系统的呢？ 这篇文章是我看代码过程的记录和总结。先看一下代码的目录结构：</p><p><img src="/2020/01/03/chromium-base-allocator/code_overview.png" alt></p><h2 id="Chromium-中的-allocator"><a href="#Chromium-中的-allocator" class="headerlink" title="Chromium 中的 allocator"></a>Chromium 中的 allocator</h2><p>Chromium code base 中用到了多个 allocator，比如 allocator_shim, PartitionAlloc，还有 Blink 中用到的 Olipan。这篇文章主要关注 allocator_shim 和 PartitionAlloc。</p><h3 id="allocator-shim"><a href="#allocator-shim" class="headerlink" title="allocator_shim"></a>allocator_shim</h3><p>allocator_shim 就是对各个平台 allocator 的封装，比如 malloc / new, 为什么要增加这一层封装呢？ 主要基于两点考虑，其一是在封装层增加很多 Security 检测逻辑，避免一些常见的安全漏洞，比如缓冲区溢出等。第二，可以 dump 更多 memery 相关的信息，方便排查内存以及性能问题等。</p><p>Chromium 有完整的 MemoryInfra 体系，包括采集 measuring data(chrome://tracing), memory dump, benchmarks (Telemetry) 和 chromeperf dashboard。这套体系的数据采集离不开自定义 allocator 的支持。</p><p><img src="/2020/01/03/chromium-base-allocator/memoryinfra.png" alt></p><h3 id="PartitionAlloc"><a href="#PartitionAlloc" class="headerlink" title="PartitionAlloc"></a>PartitionAlloc</h3><p>allocator_shim 仅仅是对系统 allocator 的封装，而 PartitionAlloc 是基于 Partitions 和 Buckets 模型实现了一个 allocator。</p><p>Partition 是一个堆，它包含特定的对象类型、特定大小的对象或特定生命周期的对象（如调用方所愿）。调用方可以根据需要创建任意多个分区。每个 Partition 包含多个Buckets。bucket 是 Partition 中包含相似大小对象的区域。</p><p>PartitionAlloc 在 Security 方面做的更好，保证每个 Partition 都是独立的，并且受到保护，不受任何其他 Partition 的影响。这样一来可以避免 buffer overflow 破坏其他 Partition 的数据。</p><h4 id="PartitionAlloc-的主要接口"><a href="#PartitionAlloc-的主要接口" class="headerlink" title="PartitionAlloc 的主要接口"></a>PartitionAlloc 的主要接口</h4><ul><li>PartitionRoot::Alloc() / PartitionRoot::Free()<ul><li>Partition 操作非线程安全</li><li>编译时决定需分配的内存大小(不能超过某个最大值)</li><li>分配对象大小必须是系统指针大小的整数倍</li></ul></li><li>PartitionRootGeneric::Alloc() / PartitionRootGeneric::Free()<ul><li>Partition 线程安全</li><li>可以分配任意大小的内存 (不能超过 INT_MAX)</li><li>Bucket 大小由待分配内存决定，自动填充为系统指针 size 整数倍, 比如申请分配大小为 4000， bucket 大小则为 4096</li></ul></li></ul><p>PartitionRoot / PartitionRootGeneric 实现的功能类似于 malloc 和 free。不同的是，该对象表示一个 “堆分区”， 每个分区在一个独立的地址空间内，互不干扰。 </p><ul><li>SizeSpecificPartitionAllocator / PartitionAllocatorGeneric</li></ul><h4 id="PartitionAlloc-的数据结构"><a href="#PartitionAlloc-的数据结构" class="headerlink" title="PartitionAlloc 的数据结构"></a>PartitionAlloc 的数据结构</h4><ol><li>PartitionSuperPageExtentEntry</li></ol><p><img src="/2020/01/03/chromium-base-allocator/PartitionSuperPageExtentEntry.png" alt></p><ol start="2"><li>PartitionRootBase</li></ol><p><img src="/2020/01/03/chromium-base-allocator/PartitionRootBase.png" alt></p><ol start="3"><li>PartitionBucket 与 PartitionPage</li></ol><p><img src="/2020/01/03/chromium-base-allocator/PartitionBucket.png" alt></p><h4 id="PartitionAlloc-的代码结构"><a href="#PartitionAlloc-的代码结构" class="headerlink" title="PartitionAlloc 的代码结构"></a>PartitionAlloc 的代码结构</h4><p><img src="/2020/01/03/chromium-base-allocator/partition_alloc.png" alt></p><h2 id="学习到的一些知识点"><a href="#学习到的一些知识点" class="headerlink" title="学习到的一些知识点"></a>学习到的一些知识点</h2><ul><li>spin lock 的用法</li><li>constexpr 关键字</li><li>volatile 关键字</li><li>unittest 与 perftest 的思路</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.geeksforgeeks.org/understanding-volatile-qualifier-in-c">Understanding “volatile” qualifier in C | Set 2 (Examples)</a></li></ol><h2 id="修改历史"><a href="#修改历史" class="headerlink" title="修改历史"></a>修改历史</h2><table><thead><tr><th>修改时间</th><th>说明</th></tr></thead><tbody><tr><td>2020-01-03</td><td>创建文档+初稿</td></tr><tr><td>2020-01-04</td><td>增加 PartitionAlloc 部分</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;allocator 是 C++ std 中引入的，为了处理各种内存管理模式（比如共享内存、垃圾回收等）的内存分配问题，负责内存的分配、回收，对象的创建析构等。&lt;/p&gt;</summary>
    
    
    
    
    <category term="基础库" scheme="https://ustcqidi.github.io/tags/%E5%9F%BA%E7%A1%80%E5%BA%93/"/>
    
    <category term="Chromium" scheme="https://ustcqidi.github.io/tags/Chromium/"/>
    
    <category term="allocator" scheme="https://ustcqidi.github.io/tags/allocator/"/>
    
  </entry>
  
  <entry>
    <title>2019 年度总结</title>
    <link href="https://ustcqidi.github.io/2019/12/29/summary-2019/"/>
    <id>https://ustcqidi.github.io/2019/12/29/summary-2019/</id>
    <published>2019-12-29T06:35:27.000Z</published>
    <updated>2025-01-04T02:21:58.745Z</updated>
    
    <content type="html"><![CDATA[<h3 id="总结-负面"><a href="#总结-负面" class="headerlink" title="总结 (负面)"></a>总结 (负面)</h3><p>平淡、稳定，有点颓的一年, 去年立下的 flag 基本没有完成：</p><ul><li>早起<ul><li>起床比较随性，经常导致儿子上学迟到</li></ul></li><li>坚持写文章<ul><li>仅写了 2-3 篇文章，质量还非常粗糙</li></ul></li><li>深度思考<ul><li>除了需要解决项目问题时，其余时间基本没有思考</li></ul></li><li>步行或跑步<ul><li>比较懒，跑步计划基本没有完成，只跑了一个半马</li></ul></li><li>多读书<ul><li>仅读了几本猎奇类的书</li></ul></li><li>学会情绪管理<ul><li>经常对儿子吼</li></ul></li></ul><h3 id="总结-正面"><a href="#总结-正面" class="headerlink" title="总结 (正面)"></a>总结 (正面)</h3><ul><li>调试能力++，学会使用 windbg 和 IDA 基本用法，能解决大部分 Crash 问题</li><li>开始关注理财投资</li></ul><span id="more"></span><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>学会了调试几板斧，大部分 Crash 能自己搞定了</p><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><p>用 Golang 给公司写了一个日志解密服务，算是学习了一门新的编程语言</p><h3 id="压力"><a href="#压力" class="headerlink" title="压力"></a>压力</h3><p>9-10 月份应该是工作压力最大的时间段，zoom 在中国被封，紧急被赶鸭子上架解决这个问题，期间压力大到睡不着觉</p><h3 id="给自己挖坑"><a href="#给自己挖坑" class="headerlink" title="给自己挖坑"></a>给自己挖坑</h3><p>发版前提交代码没有仔细测试 &amp;&amp; review，影响了各个平台的主要功能。发版当天还请假出去玩了，release 群里很多人都在找，甚至惊动到 site manager</p><h3 id="红楼梦"><a href="#红楼梦" class="headerlink" title="红楼梦"></a>红楼梦</h3><p>开车上下班的路上基本都在听红楼梦，主题曲也循环听了很多很多遍</p><h3 id="孩子入园"><a href="#孩子入园" class="headerlink" title="孩子入园"></a>孩子入园</h3><p>儿子到了入园年纪，8月份开始提前上暑期适应班。每次把儿子送教室他都哭哭啼啼不愿意让我走。老婆也开始去上班了，家里的生活节奏跟以前完全不一样了。</p><h3 id="严重违章"><a href="#严重违章" class="headerlink" title="严重违章"></a>严重违章</h3><p>严重超速违章两次被扣了两个 12 分，体验了一把满分学习</p><h3 id="游泳"><a href="#游泳" class="headerlink" title="游泳"></a>游泳</h3><p>学会了蛙泳，虽然水平很菜，但是对于旱鸭子的我已经算是一个突破</p><h3 id="基金定投"><a href="#基金定投" class="headerlink" title="基金定投"></a>基金定投</h3><p>开始接触基金定投，投资理财意识开始萌芽，以后每年会定投沪深300</p><!--### 股票兑现公司上市，行权了 25% 的期权，价值大概 50 万左右吧，但是因为流程原因还迟迟未到账 --><h3 id="副业收入"><a href="#副业收入" class="headerlink" title="副业收入"></a>副业收入</h3><p>全年副业收入74347.36, 其中主要收入还是来自兼职写代码，收入73747.36，占比99.19%；兼职写代码耗费时间较多，也会比较累，目前已经放弃所有兼职写代码的收入。</p><p>2020年主要精力放在全职工作上，业余时间做基金定投。12月份开始试玩基金定投，截止到2019年12月31日，基金收入 大约600 左右，因为是前期摸索阶段，收益率较低，但是投入个人精力很少，风险在可接受范围内，是一个性价比很高的提高收入方式。</p><p><img src="/2019/12/29/summary-2019/income.png" alt></p><p>每月收入明细如下:</p><p><img src="/2019/12/29/summary-2019/income_detail.png" alt></p><h3 id="读过最好的书"><a href="#读过最好的书" class="headerlink" title="读过最好的书"></a>读过最好的书</h3><ul><li>《红楼梦》</li></ul><h3 id="看过最好的纪录片"><a href="#看过最好的纪录片" class="headerlink" title="看过最好的纪录片"></a>看过最好的纪录片</h3><ul><li>冒险雷探长</li></ul><h3 id="新年-flag"><a href="#新年-flag" class="headerlink" title="新年 flag"></a>新年 flag</h3><ul><li>看 2-3 部高分纪录片</li><li>保持读书/听书习惯</li><li>1-2 周写一篇博客，书写有助于思考</li><li>每晚坐在书桌前至少半小时</li><li>尽量控制情绪，不要乱发脾气</li><li>买改善房</li><li>带老婆孩子去一次日本</li><li>工作日保证7点左右起床</li></ul><h4 id="理财计划"><a href="#理财计划" class="headerlink" title="理财计划"></a>理财计划</h4><ol><li>资金计划 10w+</li><li>周期1年</li><li>期望收益 10%+</li></ol><h4 id="身体健康"><a href="#身体健康" class="headerlink" title="身体健康"></a>身体健康</h4><ul><li>少喝酒、保持身体健康、体检一次</li><li>改善饮食结构，少油腻，少盐</li><li>坚持定期跑步</li><li>争取每天午睡，晚上11:00左右睡觉，最晚不要超过11:30 </li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;总结-负面&quot;&gt;&lt;a href=&quot;#总结-负面&quot; class=&quot;headerlink&quot; title=&quot;总结 (负面)&quot;&gt;&lt;/a&gt;总结 (负面)&lt;/h3&gt;&lt;p&gt;平淡、稳定，有点颓的一年, 去年立下的 flag 基本没有完成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;早起&lt;ul&gt;
&lt;li&gt;起床比较随性，经常导致儿子上学迟到&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;坚持写文章&lt;ul&gt;
&lt;li&gt;仅写了 2-3 篇文章，质量还非常粗糙&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;深度思考&lt;ul&gt;
&lt;li&gt;除了需要解决项目问题时，其余时间基本没有思考&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;步行或跑步&lt;ul&gt;
&lt;li&gt;比较懒，跑步计划基本没有完成，只跑了一个半马&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多读书&lt;ul&gt;
&lt;li&gt;仅读了几本猎奇类的书&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;学会情绪管理&lt;ul&gt;
&lt;li&gt;经常对儿子吼&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;总结-正面&quot;&gt;&lt;a href=&quot;#总结-正面&quot; class=&quot;headerlink&quot; title=&quot;总结 (正面)&quot;&gt;&lt;/a&gt;总结 (正面)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;调试能力++，学会使用 windbg 和 IDA 基本用法，能解决大部分 Crash 问题&lt;/li&gt;
&lt;li&gt;开始关注理财投资&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="年度总结" scheme="https://ustcqidi.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>用 Golang 写一个日志处理服务</title>
    <link href="https://ustcqidi.github.io/2019/04/17/go-log-decrypt/"/>
    <id>https://ustcqidi.github.io/2019/04/17/go-log-decrypt/</id>
    <published>2019-04-17T02:37:03.000Z</published>
    <updated>2025-01-04T02:21:58.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>公司产品的日志都是加密过的，需要写一个Web服务：公司的同事可以上传加密过的日志文件，后台解密后再下载。</p><span id="more"></span><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ol><li>日志文件有多大？上传中断了怎么办？</li><li>多个日志文件如何批量处理？</li><li>日志解密是I/O密集型任务，如何保证并发以及快速响应？</li><li>日志处理成功后，给用户怎样的反馈？</li><li>前后端的技术栈选型？</li><li>用户交互流程？</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol><li>大文件切片、断点续传</li><li>zip压缩</li><li>Golang 协程</li><li>Golang + React</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;公司产品的日志都是加密过的，需要写一个Web服务：公司的同事可以上传加密过的日志文件，后台解密后再下载。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Go" scheme="https://ustcqidi.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>libcurl 域名解析分析</title>
    <link href="https://ustcqidi.github.io/2019/01/17/libcurl-dns/"/>
    <id>https://ustcqidi.github.io/2019/01/17/libcurl-dns/</id>
    <published>2019-01-17T02:59:09.000Z</published>
    <updated>2025-01-04T02:21:58.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们公司的产品使用 libcurl 作为基础网络库，线上环境中经常会有域名解析失败导致的问题。libcurl 的域名解析默认情况下是调用系统 API 完成的，并且用户的网络环境可能比较复杂，比如：是否连接了代理服务器，是否开启防火墙，域名解析过程是不是被运营商劫持等等。所以对于此类问题，通常是只能在特定的机器和网络环境下复现，非常难确定具体原因。</p><span id="more"></span><p>排查这类问题中我们也逐步有了一些想法：</p><ol><li>网络诊断工具</li><li>域名解析备份机制</li><li>域名解析 PK 机制</li></ol><p>这篇文章主要记录一下我是如何实现 libcurl 域名解析 PK 机制的。</p><p>首先需要弄清下面两个问题：</p><ol><li>libcurl 的域名解析流程</li><li>域名解析 PK 流程</li></ol><h2 id="libcurl-的域名解析流程"><a href="#libcurl-的域名解析流程" class="headerlink" title="libcurl 的域名解析流程"></a>libcurl 的域名解析流程</h2><p>域名解析是网络连接的第一步，libcurl 使用了一个状态机管理网络连接的每个状态，代码在 multi.c 这个文件中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> CURLMcode <span class="title">multi_runsingle</span><span class="params">(<span class="keyword">struct</span> Curl_multi *multi,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">struct</span> curltime now,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">struct</span> Curl_easy *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span>(data-&gt;mstate) &#123;</span><br><span class="line">    <span class="keyword">case</span> CURLM_STATE_INIT:</span><br><span class="line">      <span class="comment">/* init this transfer. */</span></span><br><span class="line">      result=<span class="built_in">Curl_pretransfer</span>(data);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">        <span class="comment">/* after init, go CONNECT */</span></span><br><span class="line">        <span class="built_in">multistate</span>(data, CURLM_STATE_CONNECT);</span><br><span class="line">        <span class="built_in">Curl_pgrsTime</span>(data, TIMER_STARTOP);</span><br><span class="line">        rc = CURLM_CALL_MULTI_PERFORM;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> CURLM_STATE_CONNECT_PEND:</span><br><span class="line">      <span class="comment">/* We will stay here until there is a connection available. Then</span></span><br><span class="line"><span class="comment">         we try again in the CURLM_STATE_CONNECT state. */</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> CURLM_STATE_CONNECT:</span><br><span class="line">      <span class="comment">/* Connect. We want to get a connection identifier filled in. */</span></span><br><span class="line">      <span class="built_in">Curl_pgrsTime</span>(data, TIMER_STARTSINGLE);</span><br><span class="line">      result = <span class="built_in">Curl_connect</span>(data, &amp;data-&gt;easy_conn,</span><br><span class="line">                            &amp;async, &amp;protocol_connect);</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">case</span> CURLM_STATE_WAITRESOLVE:</span><br><span class="line">      ...</span><br><span class="line">      result = <span class="built_in">Curl_resolver_is_resolved</span>(data-&gt;easy_conn, &amp;dns);</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CURLM_STATE_CONNECT 这个状态时会发起连接请求 Curl_connect, 解析域名的调用逻辑就封装在这个方法里面。libcurl 的域名解析有同步和异步两种方式，默认是异步的方式。异步域名解析的接口定义在 asyn.h 这个头文件中。</p><p>主要接口如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Curl_resolver_is_resolved()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Called repeatedly to check if a previous name resolve request has</span></span><br><span class="line"><span class="comment"> * completed. It should also make sure to time-out if the operation seems to</span></span><br><span class="line"><span class="comment"> * take too long.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns normal CURLcode errors.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">CURLcode <span class="title">Curl_resolver_is_resolved</span><span class="params">(<span class="keyword">struct</span> connectdata *conn,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">struct</span> Curl_dns_entry **dns)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Curl_resolver_getaddrinfo() - when using this resolver</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns name information about the given hostname and port number. If</span></span><br><span class="line"><span class="comment"> * successful, the &#x27;hostent&#x27; is returned and the forth argument will point to</span></span><br><span class="line"><span class="comment"> * memory we need to free after use. That memory *MUST* be freed with</span></span><br><span class="line"><span class="comment"> * Curl_freeaddrinfo(), nothing else.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Each resolver backend must of course make sure to return data in the</span></span><br><span class="line"><span class="comment"> * correct format to comply with this.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Curl_addrinfo *<span class="title">Curl_resolver_getaddrinfo</span><span class="params">(<span class="keyword">struct</span> connectdata *conn,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> <span class="type">char</span> *hostname,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">int</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">int</span> *waitp)</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Curl_resolver_getaddrinfos 是域名解析的接口，具体实现有两种方式：asyn-thread 和 asyn-ares; 前者是在开启了一个线程然后调用系统的域名解析API，后者是使用 c-ares 这个库实现异步域名解析。默认情况下，libcurl 使用的是 asyn-thread, 如果你想使用 asyn-ares, 需要打开 USE_ARES 这个编译选项。</p><p>Curl_resolver_is_resolved 返回域名解析是否完成，libcurl multi 中有个 hearbeat 就是通过调用这个方法轮询域名解析是否完成。</p><p>整体流程图如下：</p><p><img src="/2019/01/17/libcurl-dns/libcurl_dns_flow.png" alt></p><h2 id="域名解析-PK-流程"><a href="#域名解析-PK-流程" class="headerlink" title="域名解析 PK 流程"></a>域名解析 PK 流程</h2><p>c-ares 是一个跨平台异步域名解析库，完整地实现了 DNS 协议标准，没有使用平台相关个API；因此，当我们遇到系统域名解析问题时，很自然地想到了是否可以使用 asyn-ares 做 backup 或者同时发起 asyn-thread 和 asyn-ares 两种解析方式。<br>但是 libcurl 中默认只能使用一种域名解析方式，也就时说如果打开了 USE_ARES 编译选项，就无法使用 aysn-thread 这种方式做域名解析了。所以这里需要重新定义一个编译选项并实现 asyn 接口。</p><p>如何在 libcurl 中实现域名解析 PK 呢？总结一下有以下需要解决的问题：</p><ol><li>并行地发起 asyn-thread 和 asyn-ares 两种域名解析请求</li><li>如果其中一个解析成功<ul><li>返回解析结果，状态机更新，继续处理下一个状态</li><li>取消另一个正在处理的域名解析请求</li></ul></li><li>解析失败<ul><li>如果其中一个请求失败了，忽略失败处理逻辑，继续等待另一个域名解析请求返回</li><li>如果两个请求都失败了，进行失败处理</li></ul></li><li>取消逻辑</li><li>解析状态检测</li><li>数据结构更新</li></ol><p><img src="/2019/01/17/libcurl-dns/asyn-pk.png" alt></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/32531969">从Chrome源码看DNS解析过程</a></li><li><a href="https://medium.com/tenable-techblog/remotely-exploiting-zoom-meetings-5a811342ba1d">https://medium.com/tenable-techblog/remotely-exploiting-zoom-meetings-5a811342ba1d</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我们公司的产品使用 libcurl 作为基础网络库，线上环境中经常会有域名解析失败导致的问题。libcurl 的域名解析默认情况下是调用系统 API 完成的，并且用户的网络环境可能比较复杂，比如：是否连接了代理服务器，是否开启防火墙，域名解析过程是不是被运营商劫持等等。所以对于此类问题，通常是只能在特定的机器和网络环境下复现，非常难确定具体原因。&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络" scheme="https://ustcqidi.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="DNS" scheme="https://ustcqidi.github.io/tags/DNS/"/>
    
  </entry>
  
</feed>
