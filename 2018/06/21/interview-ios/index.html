<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ustcqidi.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="iOS性能优化 block什么时候在 block 里面用 self, 不需要使用 weak self我们知道, 在使用 block 的时候, 为了避免产生循环引用, 通常需要使用 weakSelf 与 strongSelf, 写下面这样的代码：1234567__weak typeof(self) weakSelf &#x3D; self;[self doSomeBlockJob:^&amp;#123;    __s">
<meta property="og:type" content="article">
<meta property="og:title" content="Interview Notebook">
<meta property="og:url" content="https://ustcqidi.github.io/2018/06/21/interview-ios/">
<meta property="og:site_name" content="祁迪的博客">
<meta property="og:description" content="iOS性能优化 block什么时候在 block 里面用 self, 不需要使用 weak self我们知道, 在使用 block 的时候, 为了避免产生循环引用, 通常需要使用 weakSelf 与 strongSelf, 写下面这样的代码：1234567__weak typeof(self) weakSelf &#x3D; self;[self doSomeBlockJob:^&amp;#123;    __s">
<meta property="og:locale">
<meta property="og:image" content="https://ustcqidi.github.io/2018/06/21/interview-ios/iOS_perf.png">
<meta property="og:image" content="https://ustcqidi.github.io/2018/06/21/interview-ios/algo.png">
<meta property="og:image" content="https://ustcqidi.github.io/2018/06/21/interview-ios/cpp.svg">
<meta property="og:image" content="https://ustcqidi.github.io/2018/06/21/interview-ios/network.png">
<meta property="og:image" content="https://camo.githubusercontent.com/36cf7d4e1598683fe72a5e1c3e837b16840f4085/687474703a2f2f6f6f327239726e7a702e626b742e636c6f7564646e2e636f6d2f6a656c6c797468696e6b544350342e6a7067">
<meta property="og:image" content="https://ustcqidi.github.io/2018/06/21/interview-ios/tcp_cong.png">
<meta property="og:image" content="https://ustcqidi.github.io/2018/06/21/interview-ios/os.png">
<meta property="article:published_time" content="2018-06-21T09:44:47.000Z">
<meta property="article:modified_time" content="2025-01-04T02:21:58.704Z">
<meta property="article:author" content="祁迪">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ustcqidi.github.io/2018/06/21/interview-ios/iOS_perf.png">


<link rel="canonical" href="https://ustcqidi.github.io/2018/06/21/interview-ios/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-Hans","comments":true,"permalink":"https://ustcqidi.github.io/2018/06/21/interview-ios/","path":"2018/06/21/interview-ios/","title":"Interview Notebook"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Interview Notebook | 祁迪的博客</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?b4fa680bcca71536a4ad2a1ce53cf441"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="祁迪的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">祁迪的博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">企业级客户端技术探索：架构设计·性能优化·效能提升</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#iOS"><span class="nav-number">1.</span> <span class="nav-text">iOS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">1.1.</span> <span class="nav-text">性能优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#block"><span class="nav-number">1.2.</span> <span class="nav-text">block</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%9C%A8-block-%E9%87%8C%E9%9D%A2%E7%94%A8-self-%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8-weak-self"><span class="nav-number">1.2.1.</span> <span class="nav-text">什么时候在 block 里面用 self, 不需要使用 weak self</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-block-%E9%87%8C%E9%9D%A2%E8%BF%98%E9%9C%80%E8%A6%81%E5%86%99%E4%B8%80%E4%B8%AA-strongSelf-%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%86%99%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="nav-number">1.2.2.</span> <span class="nav-text">为什么 block 里面还需要写一个 strongSelf, 如果不写会怎么样?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">数据结构与算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">2.1.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="nav-number">2.2.</span> <span class="nav-text">二分搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE"><span class="nav-number">2.3.</span> <span class="nav-text">海量数据</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C"><span class="nav-number">3.</span> <span class="nav-text">C++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="nav-number">3.1.</span> <span class="nav-text">语法基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#new%E3%80%81delete%E3%80%81malloc%E3%80%81free"><span class="nav-number">3.1.1.</span> <span class="nav-text">new、delete、malloc、free</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">3.1.2.</span> <span class="nav-text">const关键字的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">3.1.3.</span> <span class="nav-text">static关键字的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#struct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.4.</span> <span class="nav-text">struct和class的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E5%8F%98%E9%87%8Fa%E7%BB%99%E5%87%BA%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">3.1.5.</span> <span class="nav-text">用变量a给出下面的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%86%99%E5%87%BAswap-x-y"><span class="nav-number">3.1.6.</span> <span class="nav-text">用宏定义写出swap(x,y)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%88%AB%E5%86%99%E5%87%BABOOL-int-float-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8Fa-%E4%B8%8E%E2%80%9C%E9%9B%B6%E2%80%9D%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.1.7.</span> <span class="nav-text">分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.8.</span> <span class="nav-text">引用与指针有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#strlen-strcpy-strcat-strcmp%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.1.9.</span> <span class="nav-text">strlen, strcpy, strcat, strcmp的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.2.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">3.2.1.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%8D%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.2.</span> <span class="nav-text">基类的析构函数不是虚函数，会带来什么问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98"><span class="nav-number">3.3.</span> <span class="nav-text">内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#memcpy%E5%92%8Cmemmove%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.1.</span> <span class="nav-text">memcpy和memmove的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.2.</span> <span class="nav-text">描述内存分配方式以及它们的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-shared-ptr-weak-ptr"><span class="nav-number">3.3.3.</span> <span class="nav-text">智能指针 shared_ptr&#x2F;weak_ptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98"><span class="nav-number">3.3.4.</span> <span class="nav-text">可能出现的内存问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STL"><span class="nav-number">3.4.</span> <span class="nav-text">STL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E5%AE%9E%E7%8E%B0STL%E4%B8%AD%E7%9A%84string%E7%B1%BB%EF%BC%8C%E5%8C%85%E6%8B%AC%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E3%80%81%E8%B5%8B%E5%80%BC%E3%80%81%E9%95%BF%E5%BA%A6%E3%80%81%E6%AF%94%E8%BE%83%E3%80%81%E7%9B%B8%E5%8A%A0"><span class="nav-number">3.4.1.</span> <span class="nav-text">C++实现STL中的string类，包括构造函数、拷贝构造函数、析构函数、赋值、长度、比较、相加</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.5.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">3.5.1.</span> <span class="nav-text">线程安全的定义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B"><span class="nav-number">4.1.</span> <span class="nav-text">单例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85"><span class="nav-number">4.2.</span> <span class="nav-text">观察者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">4.3.</span> <span class="nav-text">适配器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C"><span class="nav-number">5.</span> <span class="nav-text">网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E4%B8%8E%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="nav-number">5.1.</span> <span class="nav-text">TCP 建立连接与断开连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">5.2.</span> <span class="nav-text">TCP 拥塞控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.3.</span> <span class="nav-text">TCP和UDP的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%98%AF%E5%9F%BA%E4%BA%8EUDP%E7%9A%84"><span class="nav-number">5.4.</span> <span class="nav-text">有哪些应用层协议是基于TCP的，哪些是基于UDP的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E5%92%8C%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="nav-number">5.5.</span> <span class="nav-text">超时重传和快速重传</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">6.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">6.1.</span> <span class="nav-text">死锁产生的必要条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="nav-number">6.2.</span> <span class="nav-text">处理死锁的基本方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">6.3.</span> <span class="nav-text">线程同步</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">7.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">祁迪</p>
  <div class="site-description" itemprop="description">专注企业级客户端应用基础架构设计与性能优化，分享网络通信、数据库、APM等底层技术实践。记录 Troubleshooting、工程效能提升等实战经验，探讨大型应用开发的技术创新。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ustcqidi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ustcqidi" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://ustcqidi.github.io/2018/06/21/interview-ios/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="祁迪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="祁迪的博客">
      <meta itemprop="description" content="专注企业级客户端应用基础架构设计与性能优化，分享网络通信、数据库、APM等底层技术实践。记录 Troubleshooting、工程效能提升等实战经验，探讨大型应用开发的技术创新。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Interview Notebook | 祁迪的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Interview Notebook
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-06-21 17:44:47" itemprop="dateCreated datePublished" datetime="2018-06-21T17:44:47+08:00">2018-06-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-01-04 10:21:58" itemprop="dateModified" datetime="2025-01-04T10:21:58+08:00">2025-01-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h1><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p><img src="/2018/06/21/interview-ios/iOS_perf.png"></p>
<h2 id="block"><a href="#block" class="headerlink" title="block"></a>block</h2><h3 id="什么时候在-block-里面用-self-不需要使用-weak-self"><a href="#什么时候在-block-里面用-self-不需要使用-weak-self" class="headerlink" title="什么时候在 block 里面用 self, 不需要使用 weak self"></a>什么时候在 block 里面用 self, 不需要使用 weak self</h3><p>我们知道, 在使用 block 的时候, 为了避免产生循环引用, 通常需要使用 weakSelf 与 strongSelf, 写下面这样的代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">[self doSomeBlockJob:^&#123;</span><br><span class="line">    __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">    if (strongSelf) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><br>那么请问: 什么时候在 block 里面用 self, 不需要使用 weak self ?</p>
<span id="more"></span>
<p>当 block 本身不被 self 持有, 而被别的对象持有, 同时不产生循环引用的时候, 就不需要使用 weak self 了. 最常见的代码就是 UIView 的动画代码, 我们在使用 UIView 的 animateWithDuration:animations 方法 做动画的时候, 并不需要使用 weak self, 因为引用持有关系是:</p>
<ul>
<li>UIView 的某个负责动画的对象持有了 block</li>
<li>block 持有了 self</li>
</ul>
<p>因为 self 并不持有 block, 所以就没有循环引用产生, 因为就不需要使用 weak self 了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[UIView animateWithDuration:0.2 animations:^&#123;</span><br><span class="line">    self.alpha = 1;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>当动画结束时, UIView 会结束持有这个 block, 如果没有别的对象持有 block 的话, block 对象就会释放掉, 从而 block 会释放掉对于 self 的持有. 整个内存引用关系被解除.</p>
<h3 id="为什么-block-里面还需要写一个-strongSelf-如果不写会怎么样"><a href="#为什么-block-里面还需要写一个-strongSelf-如果不写会怎么样" class="headerlink" title="为什么 block 里面还需要写一个 strongSelf, 如果不写会怎么样?"></a>为什么 block 里面还需要写一个 strongSelf, 如果不写会怎么样?</h3><p>在 block 中先写一个 strongSelf 其实是为了避免 block 的执行过程中, 突然出现 self 被释放的尴尬情况. 通常情况下, 如果不这么做的话, 还是很容易出现一些奇怪的逻辑, 甚至闪退.</p>
<p>以 AFNetworking 中 AFNetworkReachabilityManager.m 的一段代码举例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__weak __typeof(self)weakSelf = self;</span><br><span class="line">AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">    __strong __typeof(weakSelf)strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line">    strongSelf.networkReachabilityStatus = status;</span><br><span class="line">    if (strongSelf.networkReachabilityStatusBlock) &#123;</span><br><span class="line">        strongSelf.networkReachabilityStatusBlock(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果没有 strongSelf 的那行代码, 那么后面的每一行代码执行时, self 都可能被释放掉了, 这样很可能造成逻辑异常.</p>
<p>特别是当我们正在执行 strongSelf.networkReachabilityStatusBlock(status); 这个 block 闭包时, 如果这个 block 执行到一半时 self 释放, 那么多半情况下会 Crash.</p>
<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><p><br><img src="/2018/06/21/interview-ios/algo.png"></p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>C++ 手写冒泡、选择、插入、希尔、归并、堆、快排， 参考资料: <a target="_blank" rel="noopener" href="http://yansu.org/2015/09/07/sort-algorithms.html">七种常见经典排序算法总结（C++实现）</a></p>
<h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><p>C++ 手写二分搜索，参考资料: <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">二分搜索算法</a></p>
<h2 id="海量数据"><a href="#海量数据" class="headerlink" title="海量数据"></a>海量数据</h2><p>经典思路:</p>
<ul>
<li>分而治之/hash映射 + hash统计 + 堆/快速/归并排序</li>
<li>双层桶划分</li>
<li>Bloom filter/Bitmap</li>
<li>Trie树/数据库/倒排索引</li>
<li>外排序</li>
<li>分布式处理之Hadoop/Mapreduce</li>
</ul>
<p>参考资料: <a target="_blank" rel="noopener" href="https://blog.csdn.net/v_july_v/article/details/7382693">教你如何迅速秒杀掉：99%的海量数据处理面试题</a></p>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p><br><img src="/2018/06/21/interview-ios/cpp.svg"></p>
<h2 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h2><h3 id="new、delete、malloc、free"><a href="#new、delete、malloc、free" class="headerlink" title="new、delete、malloc、free"></a>new、delete、malloc、free</h3><ul>
<li>delete会调用对象的析构函数,和new对应free只会释放内存，new调用构造函数</li>
<li>malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符</li>
<li>由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free</li>
</ul>
<h3 id="const关键字的作用"><a href="#const关键字的作用" class="headerlink" title="const关键字的作用"></a>const关键字的作用</h3><ul>
<li>欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了</li>
<li>对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const</li>
<li>在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值</li>
<li>对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量</li>
<li>对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”</li>
</ul>
<h3 id="static关键字的作用"><a href="#static关键字的作用" class="headerlink" title="static关键字的作用"></a>static关键字的作用</h3><ul>
<li>函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值</li>
<li>在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问</li>
<li>在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内</li>
<li>在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝</li>
<li>在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量</li>
</ul>
<h3 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h3><ul>
<li>在默认情况下,struct的成员变量是公共(public)的, class的成员变量是私有(private)的</li>
<li>struct保证成员按照声明顺序在内存中存储。class不能保证</li>
<li>对于继承来说，class默认是private继承，struct默认是public继承</li>
</ul>
<h3 id="用变量a给出下面的定义"><a href="#用变量a给出下面的定义" class="headerlink" title="用变量a给出下面的定义"></a>用变量a给出下面的定义</h3><ul>
<li>一个整型数</li>
<li>一个指向整型数的指针</li>
<li>一个指向指针的的指针,它指向的指针是指向一个整型数</li>
<li>一个有10个整型数的数组</li>
<li>一个有10个指针的数组,该指针是指向一个整型数的</li>
<li>一个指向有10个整型数数组的指针</li>
<li>一个指向函数的指针,该函数有一个整型参数并返回一个整型数</li>
<li>一个有10个指针的数组,该指针指向一个函数,该函数有一个整型参数并返回一个整型数</li>
</ul>
<p>答案分别是：</p>
<ul>
<li>int a;</li>
<li>int *a;</li>
<li>int **a;</li>
<li>int a[10];</li>
<li>int *a[10];</li>
<li>int (*a)[10];</li>
<li>int (*a)(int);</li>
<li>int (*a[10])(int);</li>
</ul>
<h3 id="用宏定义写出swap-x-y"><a href="#用宏定义写出swap-x-y" class="headerlink" title="用宏定义写出swap(x,y)"></a>用宏定义写出swap(x,y)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> swap(x,y) /</span></span><br><span class="line">x=x+y; /</span><br><span class="line">y=x-y; /</span><br><span class="line">x=x-y;</span><br></pre></td></tr></table></figure>
<h3 id="分别写出BOOL-int-float-指针类型的变量a-与“零”的比较语句"><a href="#分别写出BOOL-int-float-指针类型的变量a-与“零”的比较语句" class="headerlink" title="分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句"></a>分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句</h3><ul>
<li>BOOL : if (!a) or if(a)</li>
<li>int : if (a == 0)</li>
<li>pointer : if ( a != NULL) or if(a == NULL)</li>
<li>float : const EXPRESSION EXP = 0.000001; if ( a &lt; EXP &amp;&amp; a &gt;-EXP)</li>
</ul>
<h3 id="引用与指针有什么区别"><a href="#引用与指针有什么区别" class="headerlink" title="引用与指针有什么区别"></a>引用与指针有什么区别</h3><ul>
<li>引用必须被初始化，指针不必</li>
<li>引用初始化以后不能被改变，指针可以改变所指的对象</li>
<li>不存在指向空值的引用，但是存在指向空值的指针</li>
</ul>
<h3 id="strlen-strcpy-strcat-strcmp的实现"><a href="#strlen-strcpy-strcat-strcmp的实现" class="headerlink" title="strlen, strcpy, strcat, strcmp的实现"></a>strlen, strcpy, strcat, strcmp的实现</h3><p>要考虑空指针保护，参考资料: <a target="_blank" rel="noopener" href="https://blog.csdn.net/lisonglisonglisong/article/details/44278013">面试题之strcpy/strlen/strcat/strcmp的实现</a></p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>公有继承(public) <br>基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。</li>
<li>私有继承(private) <br>基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。</li>
<li>保护继承(protected) <br>基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。</li>
</ul>
<h3 id="基类的析构函数不是虚函数，会带来什么问题"><a href="#基类的析构函数不是虚函数，会带来什么问题" class="headerlink" title="基类的析构函数不是虚函数，会带来什么问题"></a>基类的析构函数不是虚函数，会带来什么问题</h3><p>派生类的析构函数用不上，会造成资源的泄漏</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="memcpy和memmove的实现"><a href="#memcpy和memmove的实现" class="headerlink" title="memcpy和memmove的实现"></a>memcpy和memmove的实现</h3><p>考虑地址重叠情况，参考资料: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoquan/p/5265273.html">memmove 和 memcpy的区别</a></p>
<h3 id="描述内存分配方式以及它们的区别"><a href="#描述内存分配方式以及它们的区别" class="headerlink" title="描述内存分配方式以及它们的区别"></a>描述内存分配方式以及它们的区别</h3><ul>
<li>从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量；</li>
<li>在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集；</li>
<li>从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多</li>
</ul>
<h3 id="智能指针-shared-ptr-weak-ptr"><a href="#智能指针-shared-ptr-weak-ptr" class="headerlink" title="智能指针 shared_ptr/weak_ptr"></a>智能指针 shared_ptr/weak_ptr</h3><p>shared_ptr 是引用计数型智能指针，在 boost 和 std::tr1 里都有提供，现代主流的 C++ 编译器都能很好地支持。shared_ptr 是一个类模板 (class template)，它只有一个类型参数，使用起来很方便。引用计数的是自动化资源管理的常用手法，当引用计数降为 0 时，对象（资源）即被销毁。weak_ptr 也是一个引用计数型智能指针，但是它不增加引用次数，即弱 (weak) 引用。</p>
<ul>
<li>shared_ptr 控制对象的生命期。shared_ptr 是强引用（想象成用铁丝绑住堆上的对象），只要有一个指向 x 对象的 shared_ptr 存在，该 x 对象就不会析构。当指向对象 x 的最后一个 shared_ptr 析构或 reset 的时候，x 保证会被销毁。</li>
<li>weak_ptr 不控制对象的生命期，但是它知道对象是否还活着（想象成用棉线轻轻拴住堆上的对象）。如果对象还活着，那么它可以提升 (promote) 为有效的 shared_ptr；如果对象已经死了，提升会失败，返回一个空的 shared_ptr。</li>
<li>shared_ptr/weak_ptr 的“计数”在主流平台上是原子操作，没有用锁，性能不俗。</li>
<li>shared_ptr/weak_ptr 的线程安全级别与 string 等 STL 容器一样。</li>
</ul>
<h3 id="可能出现的内存问题"><a href="#可能出现的内存问题" class="headerlink" title="可能出现的内存问题"></a>可能出现的内存问题</h3><ul>
<li>缓冲区溢出</li>
<li>空悬指针/野指针</li>
<li>重复释放</li>
<li>内存泄漏</li>
<li>不配对的 new[]/delete</li>
</ul>
<p>正确使用智能指针能很轻易地解决这5个问题：</p>
<ul>
<li>缓冲区溢出 ⇒ 用 vector/string 或自己编写 Buffer 类来管理缓冲区，自动记住用缓冲区的长度，并通过成员函数而不是裸指针来修改缓冲区。</li>
<li>空悬指针/野指针 ⇒ 用 shared_ptr/weak_ptr</li>
<li>重复释放 ⇒ 用 scoped_ptr，只在对象析构的时候释放一次</li>
<li>内存泄漏 ⇒ 用 scoped_ptr，对象析构的时候自动释放内存</li>
<li>不配对的 new[]/delete ⇒ 把 new[] 统统替换为 vector/scoped_array</li>
</ul>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="C-实现STL中的string类，包括构造函数、拷贝构造函数、析构函数、赋值、长度、比较、相加"><a href="#C-实现STL中的string类，包括构造函数、拷贝构造函数、析构函数、赋值、长度、比较、相加" class="headerlink" title="C++实现STL中的string类，包括构造函数、拷贝构造函数、析构函数、赋值、长度、比较、相加"></a>C++实现STL中的string类，包括构造函数、拷贝构造函数、析构函数、赋值、长度、比较、相加</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span> *str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string &amp;str);</span><br><span class="line"></span><br><span class="line">~<span class="built_in">string</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值运算符</span></span><br><span class="line">string &amp;<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span> *str);</span><br><span class="line">string &amp;<span class="keyword">operator</span>=(<span class="type">const</span> string &amp;str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接运算符</span></span><br><span class="line">string <span class="keyword">operator</span>+(<span class="type">const</span> string &amp;str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较运算符</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> string &amp;str);</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">substr</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;o, <span class="type">const</span> string &amp;str);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> *m_data;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">string::<span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span> *str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">        m_data[<span class="number">0</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        size = <span class="built_in">strlen</span>(str);</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[size + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string::<span class="built_in">string</span>(<span class="type">const</span> string &amp;str) &#123;</span><br><span class="line">    size = str.size;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[size<span class="number">+1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string::~<span class="built_in">string</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string string::<span class="keyword">operator</span>+(<span class="type">const</span> string &amp;str) &#123;</span><br><span class="line">    string newStr;</span><br><span class="line">    newStr.size=size+str.size;</span><br><span class="line">    newStr.data = <span class="keyword">new</span> <span class="type">char</span>[newStr.size<span class="number">+1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(newStr.data, data);</span><br><span class="line">    <span class="built_in">strcpy</span>(newStr.data+size, str.data);</span><br><span class="line">    <span class="keyword">return</span> newStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string &amp; string::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span> *str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == m_data)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    size=<span class="built_in">strlen</span>(str);</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[size<span class="number">+1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string &amp; string::<span class="keyword">operator</span>=(<span class="type">const</span> string &amp;str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.m_data == m_data)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    size = str.size;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[size<span class="number">+1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> string::<span class="keyword">operator</span>==(<span class="type">const</span> string &amp;str) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(m_data, str.m_data) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">string::substr</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    string newStr;</span><br><span class="line">    <span class="keyword">delete</span>[] newStr.m_data;</span><br><span class="line"></span><br><span class="line">    newStr.m_data = <span class="keyword">new</span> <span class="type">char</span>[n<span class="number">+1</span>];</span><br><span class="line">    newStr.size = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        newStr.m_data[i] = m_data[start+i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newStr.m_data[n<span class="number">+1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> newStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp; string::<span class="keyword">operator</span>&lt;&lt;(ostream &amp;o, <span class="type">const</span> string &amp;str) &#123;</span><br><span class="line">    o &lt;&lt; str.m_data;</span><br><span class="line">    retur o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">string::length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="线程安全的定义"><a href="#线程安全的定义" class="headerlink" title="线程安全的定义"></a>线程安全的定义</h3><p>一个线程安全的 class 应当满足三个条件：</p>
<ul>
<li>从多个线程访问时，其表现出正确的行为</li>
<li>无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织</li>
<li>调用端代码无需额外的同步或其他协调动作</li>
</ul>
<p>依据这个定义，C++ 标准库里的大多数类都不是线程安全的，无论 std::string 还是 std::vector 或 std::map，因为这些类通常需要在外部加锁。</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p>C++ 手写单例, 参考资料: <a target="_blank" rel="noopener" href="https://blog.csdn.net/jx232515/article/details/75635300">C++单例模式(线程安全，没有内存泄漏)</a></p>
<h2 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h2><p>举个博客订阅的例子，当博主发表新文章的时候，即博主状态发生了改变，那些订阅的读者就会收到通知，然后进行相应的动作，比如去看文章，或者收藏起来。博主与读者之间存在种一对多的依赖关系。</p>
<p>参考资料:<a target="_blank" rel="noopener" href="https://blog.csdn.net/wuzhekai1985/article/details/6674984">设计模式C++实现（15）——观察者模式</a></p>
<h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><p>在STL中就用到了适配器模式。STL实现了一种数据结构，称为双端队列（deque），支持前后两段的插入与删除。STL实现栈和队列时，没有从头开始定义它们，而是直接使用双端队列实现的。这里双端队列就扮演了适配器的角色。队列用到了它的后端插入，前端删除。而栈用到了它的后端插入，后端删除。假设栈和队列都是一种顺序容器，有两种操作：压入和弹出。</p>
<p>参考资料:<a target="_blank" rel="noopener" href="https://blog.csdn.net/wuzhekai1985/article/details/6665542">设计模式C++实现（3）——适配器模式</a></p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p><br><img src="/2018/06/21/interview-ios/network.png"></p>
<h2 id="TCP-建立连接与断开连接"><a href="#TCP-建立连接与断开连接" class="headerlink" title="TCP 建立连接与断开连接"></a>TCP 建立连接与断开连接</h2><ul>
<li>三次握手：过程，为什么需要三次握手</li>
<li>四次握手：过程，为什么需要四次握手</li>
</ul>
<p><img src="https://camo.githubusercontent.com/36cf7d4e1598683fe72a5e1c3e837b16840f4085/687474703a2f2f6f6f327239726e7a702e626b742e636c6f7564646e2e636f6d2f6a656c6c797468696e6b544350342e6a7067" alt></p>
<p>参考资料: <a target="_blank" rel="noopener" href="https://github.com/jawil/blog/issues/14">通俗大白话来理解TCP协议的三次握手和四次分手</a></p>
<h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><p>参考文章：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000004954842">TCP/IP拥塞控制复习</a></p>
<p><img src="/2018/06/21/interview-ios/tcp_cong.png" alt></p>
<h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><ul>
<li>TCP是有连接的，两台主机在进行数据交互之前必须先通过三次握手建立连接；而UDP是无连接的，没有建立连接这个过程</li>
<li>TCP是可靠的传输，TCP协议通过确认和重传机制来保证数据传输的可靠性；而UDP是不可靠的传输</li>
<li>TCP还提供了拥塞控制、滑动窗口等机制来保证传输的质量，而UDP都没有</li>
<li>TCP是基于字节流的，将数据看做无结构的字节流进行传输，当应用程序交给TCP的数据长度太长，超过MSS时，TCP就会对数据进行分段，因此TCP的数据是无边界的；而UDP是面向报文的，无论应用程序交给UDP层多长的报文，UDP都不会对数据报进行任何拆分等处理，因此UDP保留了应用层数据的边界 </li>
<li>TCP是一对一的连接，而UDP则可以支持一对一，多对多，一对多的通信</li>
</ul>
<h2 id="有哪些应用层协议是基于TCP的，哪些是基于UDP的"><a href="#有哪些应用层协议是基于TCP的，哪些是基于UDP的" class="headerlink" title="有哪些应用层协议是基于TCP的，哪些是基于UDP的"></a>有哪些应用层协议是基于TCP的，哪些是基于UDP的</h2><ul>
<li>TCP： FTP、HTTP、Telnet、SMTP、POP3、HTTPS</li>
<li>UDP：DNS、SNMP、NFS</li>
</ul>
<h2 id="超时重传和快速重传"><a href="#超时重传和快速重传" class="headerlink" title="超时重传和快速重传"></a>超时重传和快速重传</h2><ul>
<li>超时重传：当超时时间到达时，发送方还未收到对端的ACK确认，就重传该数据包</li>
<li>快速重传：当后面的序号先到达，如接收方接收到了1、 3、 4，而2没有收到，就会立即向发送方重复发送三次ACK=2的确认请求重传。如果发送方连续收到3个相同序号的ACK，就重传该数据包。而不用等待超时 </li>
</ul>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p><br><img src="/2018/06/21/interview-ios/os.png"></p>
<h2 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h2><ul>
<li>互斥：一次只有一个进程可以使用一个资源。其他进程不能访问已分配给其他进程的资源</li>
<li>请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放</li>
<li>不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</li>
<li>循环等待：存在一个封闭的进程链，使得每个资源至少占有此链中下一个进程所需要的一个资源</li>
</ul>
<h2 id="处理死锁的基本方法"><a href="#处理死锁的基本方法" class="headerlink" title="处理死锁的基本方法"></a>处理死锁的基本方法</h2><ul>
<li>预防死锁<ul>
<li>资源一次性分配</li>
<li>可剥夺资源：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）</li>
</ul>
</li>
<li>避免死锁<ul>
<li>银行家算法：系统在进行资源分配之前预先计算资源分配的安全性</li>
</ul>
</li>
<li>检测死锁<ul>
<li>为每个进程和每个资源指定一个唯一的号码，然后建立资源分配表和进程等待表</li>
</ul>
</li>
<li>解除死锁<ul>
<li>剥夺资源</li>
<li>撤消进程</li>
</ul>
</li>
</ul>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul>
<li>临界区</li>
<li>信号量</li>
<li>条件变量</li>
<li>互斥锁</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/snxHumanNb-BLUkweMxe6Q">iOS面试准备之思维导图</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"><i class="fa fa-tag"></i> 面试</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/06/14/wwdc-Advanced-Graphics-and-Animations-for-iOS-Apps/" rel="prev" title="WWDC-Advanced Graphics and Animations for iOS Apps">
                  <i class="fa fa-angle-left"></i> WWDC-Advanced Graphics and Animations for iOS Apps
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/06/25/oc-runtime-dynamic-invocation/" rel="next" title="Objective-C Runtime">
                  Objective-C Runtime <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">祁迪</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"ustcqidi/blog-comments","issue_term":"pathname","theme":"github-light","cdn":"https://utteranc.es/client.js"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
